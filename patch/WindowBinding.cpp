/* THIS FILE IS AUTOGENERATED FROM Window.webidl BY Codegen.py - DO NOT EDIT */

#include "AtomList.h"
#include "Crypto.h"
#include "CustomElementsRegistry.h"
#include "EventHandlerBinding.h"
#include "EventTargetBinding.h"
#include "ExternalBinding.h"
#include "FunctionBinding.h"
#include "ImageBitmapBinding.h"
#include "MozSelfSupportBinding.h"
#include "Navigator.h"
#include "RequestBinding.h"
#include "WindowBinding.h"
#include "WrapperFactory.h"
#include "jsapi.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/Preferences.h"
#include "mozilla/UseCounter.h"
#include "mozilla/dom/BarProps.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CustomElementsRegistry.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMStorage.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/Event.h"
#include "mozilla/dom/IDBFactory.h"
#include "mozilla/dom/MediaQueryList.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/Performance.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/Selection.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/SpeechSynthesis.h"
#include "mozilla/dom/U2F.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/cache/CacheStorage.h"
#include "nsContentUtils.h"
#include "nsGenericHTMLElement.h"
#include "nsGlobalWindow.h"
#include "nsHistory.h"
#include "nsIBrowserDOMWindow.h"
#include "nsICSSDeclaration.h"
#include "nsIControllers.h"
#include "nsIDOMOfflineResourceList.h"
#include "nsIDocument.h"
#include "nsIMessageManager.h"
#include "nsISupports.h"
#include "nsJSUtils.h"
#include "nsLocation.h"
#include "nsPIDOMWindow.h"
#include "nsScreen.h"
#include "nsWindowRoot.h"
#include "xpcjsid.h"

namespace mozilla {
namespace dom {

namespace ScrollBehaviorValues {
extern const EnumEntry strings[4] = {
  {"auto", 4},
  {"instant", 7},
  {"smooth", 6},
  { nullptr, 0 }
};
} // namespace ScrollBehaviorValues

bool
ToJSValue(JSContext* aCx, ScrollBehavior aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(ScrollBehaviorValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, ScrollBehaviorValues::strings[uint32_t(aArgument)].value,
                      ScrollBehaviorValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningExternalOrWindowProxy& aUnion, const char* aName, uint32_t aFlags)
{
  if (aUnion.IsExternal()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsExternal(), "mExternal", aFlags);
  } else if (aUnion.IsWindowProxy()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsWindowProxy(), "mWindowProxy", aFlags);
  }
}


void
ImplCycleCollectionUnlink(OwningExternalOrWindowProxy& aUnion)
{
  aUnion.Uninit();
}


bool
ExternalOrWindowProxy::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eExternal: {
      if (!GetOrCreateDOMReflector(cx, mValue.mExternal.Value(), rval)) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eWindowProxy: {
      if (!WrapObject(cx, mValue.mWindowProxy.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


OwningNonNull<mozilla::dom::External>&
OwningExternalOrWindowProxy::RawSetAsExternal()
{
  if (mType == eExternal) {
    return mValue.mExternal.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eExternal;
  return mValue.mExternal.SetValue();
}

OwningNonNull<mozilla::dom::External>&
OwningExternalOrWindowProxy::SetAsExternal()
{
  if (mType == eExternal) {
    return mValue.mExternal.Value();
  }
  Uninit();
  mType = eExternal;
  return mValue.mExternal.SetValue();
}

bool
OwningExternalOrWindowProxy::TrySetToExternal(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::External>& memberSlot = RawSetAsExternal();
    static_assert(IsRefcounted<mozilla::dom::External>::value, "We can only store refcounted classes.");{
      nsresult rv = UnwrapObject<prototypes::id::External, mozilla::dom::External>(&value.toObject(), memberSlot);
      if (NS_FAILED(rv)) {
        DestroyExternal();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

void
OwningExternalOrWindowProxy::DestroyExternal()
{
  MOZ_ASSERT(IsExternal(), "Wrong type!");
  mValue.mExternal.Destroy();
  mType = eUninitialized;
}




RefPtr<nsPIDOMWindowOuter>&
OwningExternalOrWindowProxy::RawSetAsWindowProxy()
{
  if (mType == eWindowProxy) {
    return mValue.mWindowProxy.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eWindowProxy;
  return mValue.mWindowProxy.SetValue();
}

RefPtr<nsPIDOMWindowOuter>&
OwningExternalOrWindowProxy::SetAsWindowProxy()
{
  if (mType == eWindowProxy) {
    return mValue.mWindowProxy.Value();
  }
  Uninit();
  mType = eWindowProxy;
  return mValue.mWindowProxy.SetValue();
}

bool
OwningExternalOrWindowProxy::TrySetToWindowProxy(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    RefPtr<nsPIDOMWindowOuter>& memberSlot = RawSetAsWindowProxy();
    static_assert(IsRefcounted<nsPIDOMWindowOuter>::value, "We can only store refcounted classes.");RefPtr<nsPIDOMWindowOuter> mWindowProxyHolder;
    JS::Rooted<JSObject*> source(cx, &value.toObject());
    if (NS_FAILED(UnwrapArg<nsPIDOMWindowOuter>(source, getter_AddRefs(mWindowProxyHolder)))) {
      DestroyWindowProxy();
      tryNext = true;
      return true;
    }
    MOZ_ASSERT(mWindowProxyHolder);
    memberSlot = mWindowProxyHolder;
  }
  return true;
}

void
OwningExternalOrWindowProxy::DestroyWindowProxy()
{
  MOZ_ASSERT(IsWindowProxy(), "Wrong type!");
  mValue.mWindowProxy.Destroy();
  mType = eUninitialized;
}




void
OwningExternalOrWindowProxy::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eExternal: {
      DestroyExternal();
      break;
    }
    case eWindowProxy: {
      DestroyWindowProxy();
      break;
    }
  }
}

bool
OwningExternalOrWindowProxy::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eExternal: {
      if (!GetOrCreateDOMReflector(cx, mValue.mExternal.Value(), rval)) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eWindowProxy: {
      if (!WrapObject(cx, mValue.mWindowProxy.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningExternalOrWindowProxy::TraceUnion(JSTracer* trc)
{
}

void
OwningExternalOrWindowProxy::operator=(const OwningExternalOrWindowProxy& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eExternal: {
      SetAsExternal() = aOther.GetAsExternal();
      break;
    }
    case eWindowProxy: {
      SetAsWindowProxy() = aOther.GetAsWindowProxy();
      break;
    }
  }
}



ScrollOptions::ScrollOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
ScrollOptions::InitIds(JSContext* cx, ScrollOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->behavior_id.init(cx, "behavior")) {
    return false;
  }
  return true;
}

bool
ScrollOptions::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  ScrollOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ScrollOptionsAtoms>(cx);
    if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  { // scope for isConvertible
    bool isConvertible;
    if (!IsConvertibleToDictionary(cx, val, &isConvertible)) {
      return false;
    }
    if (!isConvertible) {
      return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY, sourceDescription);
    }
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->behavior_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      bool ok;
      int index = FindEnumStringIndex<true>(cx, temp.ref(), ScrollBehaviorValues::strings, "ScrollBehavior", "'behavior' member of ScrollOptions", &ok);
      if (!ok) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mBehavior = static_cast<ScrollBehavior>(index);
    }
  } else {
    mBehavior = ScrollBehavior::Auto;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ScrollOptions::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
ScrollOptions::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ScrollOptionsAtoms* atomsCache = GetAtomCache<ScrollOptionsAtoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    ScrollBehavior const & currentValue = mBehavior;
    if (!ToJSValue(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->behavior_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  return true;
}

bool
ScrollOptions::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
ScrollOptions::TraceDictionary(JSTracer* trc)
{
}

void
ScrollOptions::operator=(const ScrollOptions& aOther)
{
  mBehavior = aOther.mBehavior;
}

namespace binding_detail {
} // namespace binding_detail



ScrollToOptions::ScrollToOptions()
  : ScrollOptions(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
ScrollToOptions::InitIds(JSContext* cx, ScrollToOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->top_id.init(cx, "top") ||
      !atomsCache->left_id.init(cx, "left")) {
    return false;
  }
  return true;
}

bool
ScrollToOptions::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  ScrollToOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ScrollToOptionsAtoms>(cx);
    if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  // Per spec, we init the parent's members first
  if (!ScrollOptions::Init(cx, val)) {
    return false;
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->left_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mLeft.Construct();
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), &(mLeft.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->top_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mTop.Construct();
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), &(mTop.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
ScrollToOptions::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ScrollToOptionsAtoms* atomsCache = GetAtomCache<ScrollToOptionsAtoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }

  // Per spec, we define the parent's members first
  if (!ScrollOptions::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());

  if (mLeft.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      double const & currentValue = mLeft.InternalValue();
      temp.set(JS_NumberValue(double(currentValue)));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->left_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mTop.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      double const & currentValue = mTop.InternalValue();
      temp.set(JS_NumberValue(double(currentValue)));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->top_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  return true;
}

void
ScrollToOptions::TraceDictionary(JSTracer* trc)
{
  ScrollOptions::TraceDictionary(trc);
}

void
ScrollToOptions::operator=(const ScrollToOptions& aOther)
{
  ScrollOptions::operator=(aOther);
  mLeft.Reset();
  if (aOther.mLeft.WasPassed()) {
    mLeft.Construct(aOther.mLeft.Value());
  }
  mTop.Reset();
  if (aOther.mTop.WasPassed()) {
    mTop.Construct(aOther.mTop.Value());
  }
}

namespace binding_detail {
} // namespace binding_detail


void
OverfillCallback::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, uint32_t overfill, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setNumber(overfill);
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



void
FrameRequestCallback::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, double time, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].set(JS_NumberValue(double(time)));
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace ChromeWindowBinding {

static bool
_hasInstance(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.get(0).isObject()) {
    args.rval().setBoolean(false);
    return true;
  }

  JS::Rooted<JSObject*> instance(cx, &args[0].toObject());

  const DOMJSClass* domClass = GetDOMClass(js::UncheckedUnwrap(instance, /* stopAtWindowProxy = */ false));
  if (!domClass) {
    // Not a DOM object, so certainly not an instance of this interface
    args.rval().setBoolean(false);
    return true;
  }

  if (domClass->mInterfaceChain[PrototypeTraits<prototypes::id::Window>::Depth] == prototypes::id::Window) {
    args.rval().setBoolean(UnwrapDOMObject<nsGlobalWindow>(js::UncheckedUnwrap(instance, /* stopAtWindowProxy = */ false))->IsChromeWindow());
    return true;
  }
  args.rval().setBoolean(false);
  return true;
}

static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_SYM_FNSPEC(hasInstance, _hasInstance, nullptr, 1, JSPROP_READONLY | JSPROP_PERMANENT, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sStaticMethods_ids[2];

static const ConstantSpec sConstants_specs[] = {
  { "STATE_MAXIMIZED", JS::Int32Value(1) },
  { "STATE_MINIMIZED", JS::Int32Value(2) },
  { "STATE_NORMAL", JS::Int32Value(3) },
  { "STATE_FULLSCREEN", JS::Int32Value(4) },
  { 0, JS::UndefinedValue() }
};

static PrefableDisablers sConstants_disablers0 = {
  true, false, 0, &nsGlobalWindow::IsPrivilegedChromeWindow
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const ConstantSpec> sConstants[] = {
  { &sConstants_disablers0, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static jsid sConstants_ids[5];


static const NativePropertiesN<2> sNativeProperties = {
  -1,
  true,  0 /* sStaticMethods */,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  true,  1 /* sConstants */,
  {
    { sStaticMethods, sStaticMethods_ids, sStaticMethods_specs },
    { sConstants, sConstants_ids, sConstants_specs }
  }
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::_ID_Count,
  constructors::id::ChromeWindow,
  nullptr
} };

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  false,
  prototypes::id::_ID_Count,
  0,
  sNativePropertyHooks,
  "function ChromeWindow() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return IsChromeOrXBL(aCx, aObj);
}

JSObject*
DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal)
{
  return GetConstructorObjectHandle(aCx, aDefineOnGlobal);
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static bool sIdsInited = false;
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sStaticMethods, sStaticMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sConstants, sConstants_ids)) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = nullptr;
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::ChromeWindow);
  dom::CreateInterfaceObjects(aCx, aGlobal, nullptr,
                              nullptr, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "ChromeWindow", aDefineOnGlobal,
                              nullptr,
                              false);
}

JS::Handle<JSObject*>
GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal)
{
  /* Get the interface object for this class.  This will create the object as
     needed. */

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);
  if (!protoAndIfaceCache.EntrySlotIfExists(constructors::id::ChromeWindow)) {
    JS::Rooted<JSObject*> rootedGlobal(aCx, global);
    CreateInterfaceObjects(aCx, rootedGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceCache.EntrySlotMustExist(constructors::id::ChromeWindow).address());
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace ChromeWindowBinding



namespace WindowBinding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<EventTargetBinding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

static bool
get_window(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> reflector(cx);
  // Safe to do an unchecked unwrap, since we've gotten this far.
  // Also make sure to unwrap outer windows, since we want the
  // real DOM object.
  reflector = IsDOMObject(obj) ? obj : js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false);
  {
    // Scope for cachedVal
    JS::Value cachedVal = js::GetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 0));
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of reflector,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<nsGlobalWindow>(self->Window()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  { // Make sure we wrap and store in the slot in reflector's compartment
    JSAutoCompartment ac(cx, reflector);
    do { // block we break out of when done wrapping
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (0);
    js::SetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 0), args.rval());
  }
  // And now make sure args.rval() is in the caller compartment
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo window_getterinfo = {
  { (JSJitGetterOp)get_window },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 0)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) < 5, "There is no slot for us");

static bool
get_self(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> reflector(cx);
  // Safe to do an unchecked unwrap, since we've gotten this far.
  // Also make sure to unwrap outer windows, since we want the
  // real DOM object.
  reflector = IsDOMObject(obj) ? obj : js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false);
  {
    // Scope for cachedVal
    JS::Value cachedVal = js::GetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 1));
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of reflector,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<nsGlobalWindow>(self->Self()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  { // Make sure we wrap and store in the slot in reflector's compartment
    JSAutoCompartment ac(cx, reflector);
    do { // block we break out of when done wrapping
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (0);
    js::SetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 1), args.rval());
  }
  // And now make sure args.rval() is in the caller compartment
  return MaybeWrapValue(cx, args.rval());
}

static bool
set_self(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "self", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo self_getterinfo = {
  { (JSJitGetterOp)get_self },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 1)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < 5, "There is no slot for us");
static const JSJitInfo self_setterinfo = {
  { (JSJitGetterOp)set_self },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_document(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> reflector(cx);
  // Safe to do an unchecked unwrap, since we've gotten this far.
  // Also make sure to unwrap outer windows, since we want the
  // real DOM object.
  reflector = IsDOMObject(obj) ? obj : js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false);
  {
    // Scope for cachedVal
    JS::Value cachedVal = js::GetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 2));
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of reflector,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<nsIDocument>(self->GetDocument()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  { // Make sure we wrap and store in the slot in reflector's compartment
    JSAutoCompartment ac(cx, reflector);
    do { // block we break out of when done wrapping
      if (!result) {
        args.rval().setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (0);
    js::SetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 2), args.rval());
  }
  // And now make sure args.rval() is in the caller compartment
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo document_getterinfo = {
  { (JSJitGetterOp)get_document },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 2)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) < 5, "There is no slot for us");

static bool
get_name(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->GetName(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_name(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->SetName(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo name_getterinfo = {
  { (JSJitGetterOp)get_name },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo name_setterinfo = {
  { (JSJitGetterOp)set_name },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_location(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsLocation>(self->GetLocation(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_location(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "location", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Window.location");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "href", args[0]);
}

static const JSJitInfo location_getterinfo = {
  { (JSJitGetterOp)get_location },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo location_setterinfo = {
  { (JSJitGetterOp)set_location },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_history(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsHistory>(self->GetHistory(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo history_getterinfo = {
  { (JSJitGetterOp)get_history },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_customElements(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<mozilla::dom::CustomElementsRegistry>(self->CustomElements()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo customElements_getterinfo = {
  { (JSJitGetterOp)get_customElements },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_locationbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetLocationbar(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_locationbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "locationbar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo locationbar_getterinfo = {
  { (JSJitGetterOp)get_locationbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo locationbar_setterinfo = {
  { (JSJitGetterOp)set_locationbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_menubar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetMenubar(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_menubar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "menubar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo menubar_getterinfo = {
  { (JSJitGetterOp)get_menubar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo menubar_setterinfo = {
  { (JSJitGetterOp)set_menubar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_personalbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetPersonalbar(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_personalbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "personalbar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo personalbar_getterinfo = {
  { (JSJitGetterOp)get_personalbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo personalbar_setterinfo = {
  { (JSJitGetterOp)set_personalbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollbars(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetScrollbars(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_scrollbars(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "scrollbars", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo scrollbars_getterinfo = {
  { (JSJitGetterOp)get_scrollbars },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo scrollbars_setterinfo = {
  { (JSJitGetterOp)set_scrollbars },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_statusbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetStatusbar(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_statusbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "statusbar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo statusbar_getterinfo = {
  { (JSJitGetterOp)get_statusbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo statusbar_setterinfo = {
  { (JSJitGetterOp)set_statusbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_toolbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::BarProp>(self->GetToolbar(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_toolbar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "toolbar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo toolbar_getterinfo = {
  { (JSJitGetterOp)get_toolbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo toolbar_setterinfo = {
  { (JSJitGetterOp)set_toolbar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_status(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->GetStatus(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_status(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->SetStatus(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo status_getterinfo = {
  { (JSJitGetterOp)get_status },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo status_setterinfo = {
  { (JSJitGetterOp)set_status },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
close(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Close(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo close_methodinfo = {
  { (JSJitGetterOp)close },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_closed(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  bool result(self->GetClosed(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo closed_getterinfo = {
  { (JSJitGetterOp)get_closed },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
stop(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  binding_detail::FastErrorResult rv;
  self->Stop(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo stop_methodinfo = {
  { (JSJitGetterOp)stop },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
focus(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Focus(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo focus_methodinfo = {
  { (JSJitGetterOp)focus },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
blur(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  binding_detail::FastErrorResult rv;
  self->Blur(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo blur_methodinfo = {
  { (JSJitGetterOp)blur },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_frames(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsPIDOMWindowOuter>(self->GetFrames(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_frames(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "frames", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo frames_getterinfo = {
  { (JSJitGetterOp)get_frames },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo frames_setterinfo = {
  { (JSJitGetterOp)set_frames },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  uint32_t result(self->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static bool
set_length(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "length", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo length_getterinfo = {
  { (JSJitGetterOp)get_length },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo length_setterinfo = {
  { (JSJitGetterOp)set_length },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_top(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsPIDOMWindowOuter>(self->GetTop(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo top_getterinfo = {
  { (JSJitGetterOp)get_top },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_opener(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetOpener(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_opener(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetOpener(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo opener_getterinfo = {
  { (JSJitGetterOp)get_opener },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo opener_setterinfo = {
  { (JSJitGetterOp)set_opener },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_parent(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsPIDOMWindowOuter>(self->GetParent(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_parent(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "parent", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo parent_getterinfo = {
  { (JSJitGetterOp)get_parent },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo parent_setterinfo = {
  { (JSJitGetterOp)set_parent },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_frameElement(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Element>(self->GetFrameElement(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo frameElement_getterinfo = {
  { (JSJitGetterOp)get_frameElement },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
open(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg0.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FakeString arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg1.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FakeString arg2;
  if (args.hasDefined(2)) {
    if (!ConvertJSValueToString(cx, args[2], eEmpty, eStringify, arg2)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg2.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsPIDOMWindowOuter>(self->Open(NonNullHelper(Constify(arg0)), NonNullHelper(Constify(arg1)), NonNullHelper(Constify(arg2)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo open_methodinfo = {
  { (JSJitGetterOp)open },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_navigator(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Navigator>(self->GetNavigator(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo navigator_getterinfo = {
  { (JSJitGetterOp)get_navigator },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_external(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::External>(self->GetExternal(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_external(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "external", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo external_getterinfo = {
  { (JSJitGetterOp)get_external },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo external_setterinfo = {
  { (JSJitGetterOp)set_external },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_applicationCache(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIDOMOfflineResourceList>(self->GetApplicationCache(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo applicationCache_getterinfo = {
  { (JSJitGetterOp)get_applicationCache },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
alert(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
          // Return false from the JSNative in order to trigger
          // an uncatchable exception.
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          return false;
      }
      binding_detail::FastErrorResult rv;
      self->Alert(rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
          // Return false from the JSNative in order to trigger
          // an uncatchable exception.
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          return false;
      }
      binding_detail::FakeString arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      binding_detail::FastErrorResult rv;
      self->Alert(NonNullHelper(Constify(arg0)), rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.alert");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo alert_methodinfo = {
  { (JSJitGetterOp)alert },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
confirm(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg0.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  bool result(self->Confirm(NonNullHelper(Constify(arg0)), rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo confirm_methodinfo = {
  { (JSJitGetterOp)confirm },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
prompt(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg0.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FakeString arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg1.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->Prompt(NonNullHelper(Constify(arg0)), NonNullHelper(Constify(arg1)), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo prompt_methodinfo = {
  { (JSJitGetterOp)prompt },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
print(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Print(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo print_methodinfo = {
  { (JSJitGetterOp)print },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
showModalDialog(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.showModalDialog");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  JS::Rooted<JS::Value> arg1(cx);
  if (args.hasDefined(1)) {
    arg1 = args[1];
  } else {
    arg1 = JS::UndefinedValue();
  }
  binding_detail::FakeString arg2;
  if (args.hasDefined(2)) {
    if (!ConvertJSValueToString(cx, args[2], eStringify, eStringify, arg2)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg2.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->ShowModalDialog(cx, NonNullHelper(Constify(arg0)), arg1, NonNullHelper(Constify(arg2)), &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo showModalDialog_methodinfo = {
  { (JSJitGetterOp)showModalDialog },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
postMessage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.postMessage");
  }
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FakeString arg1;
  if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
    return false;
  }
  Optional<Sequence<JS::Value>> arg2;
  Maybe<SequenceRooter<JS::Value>> arg2_holder;
  if (args.hasDefined(2)) {
    arg2.Construct();
    arg2_holder.emplace(cx, &arg2.Value());
    if (args[2].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[2], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Argument 3 of Window.postMessage");
        return false;
      }
      Sequence<JS::Value> &arr = arg2.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Argument 3 of Window.postMessage");
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->PostMessageMoz(cx, arg0, NonNullHelper(Constify(arg1)), Constify(arg2), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo postMessage_methodinfo = {
  { (JSJitGetterOp)postMessage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oninstall(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOninstall());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oninstall(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOninstall(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oninstall_getterinfo = {
  { (JSJitGetterOp)get_oninstall },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oninstall_setterinfo = {
  { (JSJitGetterOp)set_oninstall },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
captureEvents(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  self->CaptureEvents();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo captureEvents_methodinfo = {
  { (JSJitGetterOp)captureEvents },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
releaseEvents(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  self->ReleaseEvents();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo releaseEvents_methodinfo = {
  { (JSJitGetterOp)releaseEvents },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getSelection(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Selection>(self->GetSelection(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getSelection_methodinfo = {
  { (JSJitGetterOp)getSelection },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getComputedStyle(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.getComputedStyle");
  }
  NonNull<mozilla::dom::Element> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Window.getComputedStyle", "Element");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.getComputedStyle");
    return false;
  }
  binding_detail::FakeString arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg1.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsICSSDeclaration>(self->GetComputedStyle(NonNullHelper(arg0), NonNullHelper(Constify(arg1)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!IsPointer<decltype(result)>::value,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getComputedStyle_methodinfo = {
  { (JSJitGetterOp)getComputedStyle },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
matchMedia(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.matchMedia");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::MediaQueryList>(self->MatchMedia(NonNullHelper(Constify(arg0)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!IsPointer<decltype(result)>::value,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo matchMedia_methodinfo = {
  { (JSJitGetterOp)matchMedia },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_screen(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsScreen>(self->GetScreen(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
set_screen(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "screen", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo screen_getterinfo = {
  { (JSJitGetterOp)get_screen },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo screen_setterinfo = {
  { (JSJitGetterOp)set_screen },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
moveTo(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.moveTo");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->MoveTo(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo moveTo_methodinfo = {
  { (JSJitGetterOp)moveTo },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
moveBy(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.moveBy");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->MoveBy(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo moveBy_methodinfo = {
  { (JSJitGetterOp)moveBy },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
resizeTo(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.resizeTo");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->ResizeTo(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo resizeTo_methodinfo = {
  { (JSJitGetterOp)resizeTo },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
resizeBy(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.resizeBy");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->ResizeBy(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo resizeBy_methodinfo = {
  { (JSJitGetterOp)resizeBy },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_innerWidth(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetInnerWidth(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_innerWidth(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetInnerWidth(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo innerWidth_getterinfo = {
  { (JSJitGetterOp)get_innerWidth },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo innerWidth_setterinfo = {
  { (JSJitGetterOp)set_innerWidth },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_innerHeight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetInnerHeight(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_innerHeight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetInnerHeight(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo innerHeight_getterinfo = {
  { (JSJitGetterOp)get_innerHeight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo innerHeight_setterinfo = {
  { (JSJitGetterOp)set_innerHeight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
scroll(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      binding_detail::FastScrollToOptions arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of Window.scroll", false)) {
        return false;
      }
      self->Scroll(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 2: {
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], &arg0)) {
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], &arg1)) {
        return false;
      }
      self->Scroll(arg0, arg1);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.scroll");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo scroll_methodinfo = {
  { (JSJitGetterOp)scroll },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
scrollTo(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      binding_detail::FastScrollToOptions arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of Window.scrollTo", false)) {
        return false;
      }
      self->ScrollTo(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 2: {
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], &arg0)) {
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], &arg1)) {
        return false;
      }
      self->ScrollTo(arg0, arg1);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.scrollTo");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo scrollTo_methodinfo = {
  { (JSJitGetterOp)scrollTo },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
scrollBy(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      binding_detail::FastScrollToOptions arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of Window.scrollBy", false)) {
        return false;
      }
      self->ScrollBy(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 2: {
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], &arg0)) {
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], &arg1)) {
        return false;
      }
      self->ScrollBy(arg0, arg1);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.scrollBy");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo scrollBy_methodinfo = {
  { (JSJitGetterOp)scrollBy },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
mozScrollSnap(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  self->MozScrollSnap();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo mozScrollSnap_methodinfo = {
  { (JSJitGetterOp)mozScrollSnap },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollX(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_scrollX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "scrollX", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo scrollX_getterinfo = {
  { (JSJitGetterOp)get_scrollX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo scrollX_setterinfo = {
  { (JSJitGetterOp)set_scrollX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_pageXOffset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetPageXOffset(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_pageXOffset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "pageXOffset", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo pageXOffset_getterinfo = {
  { (JSJitGetterOp)get_pageXOffset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo pageXOffset_setterinfo = {
  { (JSJitGetterOp)set_pageXOffset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollY(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_scrollY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "scrollY", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo scrollY_getterinfo = {
  { (JSJitGetterOp)get_scrollY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo scrollY_setterinfo = {
  { (JSJitGetterOp)set_scrollY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_pageYOffset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetPageYOffset(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_pageYOffset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "pageYOffset", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo pageYOffset_getterinfo = {
  { (JSJitGetterOp)get_pageYOffset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo pageYOffset_setterinfo = {
  { (JSJitGetterOp)set_pageYOffset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_screenX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetScreenX(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_screenX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetScreenX(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo screenX_getterinfo = {
  { (JSJitGetterOp)get_screenX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo screenX_setterinfo = {
  { (JSJitGetterOp)set_screenX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_screenY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetScreenY(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_screenY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetScreenY(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo screenY_getterinfo = {
  { (JSJitGetterOp)get_screenY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo screenY_setterinfo = {
  { (JSJitGetterOp)set_screenY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_outerWidth(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetOuterWidth(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_outerWidth(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetOuterWidth(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo outerWidth_getterinfo = {
  { (JSJitGetterOp)get_outerWidth },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo outerWidth_setterinfo = {
  { (JSJitGetterOp)set_outerWidth },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_outerHeight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetOuterHeight(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_outerHeight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetOuterHeight(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo outerHeight_getterinfo = {
  { (JSJitGetterOp)get_outerHeight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo outerHeight_setterinfo = {
  { (JSJitGetterOp)set_outerHeight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
mozRequestOverfill(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.mozRequestOverfill");
  }
  RootedCallback<OwningNonNull<binding_detail::FastOverfillCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastOverfillCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 1 of Window.mozRequestOverfill");
      return false;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.mozRequestOverfill");
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->MozRequestOverfill(NonNullHelper(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo mozRequestOverfill_methodinfo = {
  { (JSJitGetterOp)mozRequestOverfill },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
requestAnimationFrame(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.requestAnimationFrame");
  }
  RootedCallback<OwningNonNull<binding_detail::FastFrameRequestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastFrameRequestCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 1 of Window.requestAnimationFrame");
      return false;
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.requestAnimationFrame");
    return false;
  }
  binding_detail::FastErrorResult rv;
  int32_t result(self->RequestAnimationFrame(NonNullHelper(arg0), rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo requestAnimationFrame_methodinfo = {
  { (JSJitGetterOp)requestAnimationFrame },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
cancelAnimationFrame(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.cancelAnimationFrame");
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->CancelAnimationFrame(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo cancelAnimationFrame_methodinfo = {
  { (JSJitGetterOp)cancelAnimationFrame },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_performance(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> reflector(cx);
  // Safe to do an unchecked unwrap, since we've gotten this far.
  // Also make sure to unwrap outer windows, since we want the
  // real DOM object.
  reflector = IsDOMObject(obj) ? obj : js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false);
  {
    // Scope for cachedVal
    JS::Value cachedVal = js::GetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 3));
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of reflector,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<mozilla::dom::Performance>(self->GetPerformance()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  { // Make sure we wrap and store in the slot in reflector's compartment
    JSAutoCompartment ac(cx, reflector);
    do { // block we break out of when done wrapping
      if (!result) {
        args.rval().setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (0);
    js::SetReservedSlot(reflector, (DOM_INSTANCE_RESERVED_SLOTS + 3), args.rval());
  }
  // And now make sure args.rval() is in the caller compartment
  return MaybeWrapValue(cx, args.rval());
}

static bool
set_performance(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "performance", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo performance_getterinfo = {
  { (JSJitGetterOp)get_performance },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 3)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) < 5, "There is no slot for us");
static const JSJitInfo performance_setterinfo = {
  { (JSJitGetterOp)set_performance },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_caches(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::cache::CacheStorage>(self->GetCaches(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo caches_getterinfo = {
  { (JSJitGetterOp)get_caches },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getDefaultComputedStyle(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.getDefaultComputedStyle");
  }
  NonNull<mozilla::dom::Element> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Window.getDefaultComputedStyle", "Element");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.getDefaultComputedStyle");
    return false;
  }
  binding_detail::FakeString arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg1.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsICSSDeclaration>(self->GetDefaultComputedStyle(NonNullHelper(arg0), NonNullHelper(Constify(arg1)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!IsPointer<decltype(result)>::value,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getDefaultComputedStyle_methodinfo = {
  { (JSJitGetterOp)getDefaultComputedStyle },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
scrollByLines(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.scrollByLines");
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  binding_detail::FastScrollOptions arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue,  "Argument 2 of Window.scrollByLines", false)) {
    return false;
  }
  self->ScrollByLines(arg0, Constify(arg1));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo scrollByLines_methodinfo = {
  { (JSJitGetterOp)scrollByLines },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
scrollByPages(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.scrollByPages");
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  binding_detail::FastScrollOptions arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue,  "Argument 2 of Window.scrollByPages", false)) {
    return false;
  }
  self->ScrollByPages(arg0, Constify(arg1));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo scrollByPages_methodinfo = {
  { (JSJitGetterOp)scrollByPages },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
sizeToContent(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->SizeToContent(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo sizeToContent_methodinfo = {
  { (JSJitGetterOp)sizeToContent },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_controllers(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIControllers>(self->GetControllers(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_controllers(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "controllers", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo controllers_getterinfo = {
  { (JSJitGetterOp)get_controllers },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo controllers_setterinfo = {
  { (JSJitGetterOp)set_controllers },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_realFrameElement(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Element>(self->GetRealFrameElement(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo realFrameElement_getterinfo = {
  { (JSJitGetterOp)get_realFrameElement },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_mozInnerScreenX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  float result(self->GetMozInnerScreenX(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo mozInnerScreenX_getterinfo = {
  { (JSJitGetterOp)get_mozInnerScreenX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_mozInnerScreenY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  float result(self->GetMozInnerScreenY(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo mozInnerScreenY_getterinfo = {
  { (JSJitGetterOp)get_mozInnerScreenY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_devicePixelRatio(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  float result(self->GetDevicePixelRatio(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static bool
set_devicePixelRatio(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "devicePixelRatio", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo devicePixelRatio_getterinfo = {
  { (JSJitGetterOp)get_devicePixelRatio },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo devicePixelRatio_setterinfo = {
  { (JSJitGetterOp)set_devicePixelRatio },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollMinX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollMinX(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo scrollMinX_getterinfo = {
  { (JSJitGetterOp)get_scrollMinX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollMinY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollMinY(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo scrollMinY_getterinfo = {
  { (JSJitGetterOp)get_scrollMinY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollMaxX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollMaxX(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_scrollMaxX(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "scrollMaxX", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo scrollMaxX_getterinfo = {
  { (JSJitGetterOp)get_scrollMaxX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo scrollMaxX_setterinfo = {
  { (JSJitGetterOp)set_scrollMaxX },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_scrollMaxY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  int32_t result(self->GetScrollMaxY(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static bool
set_scrollMaxY(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "scrollMaxY", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo scrollMaxY_getterinfo = {
  { (JSJitGetterOp)get_scrollMaxY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo scrollMaxY_setterinfo = {
  { (JSJitGetterOp)set_scrollMaxY },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_fullScreen(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  bool result(self->GetFullScreen(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static bool
set_fullScreen(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->SetFullScreen(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo fullScreen_getterinfo = {
  { (JSJitGetterOp)get_fullScreen },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo fullScreen_setterinfo = {
  { (JSJitGetterOp)set_fullScreen },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
back(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Back(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo back_methodinfo = {
  { (JSJitGetterOp)back },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
forward(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Forward(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo forward_methodinfo = {
  { (JSJitGetterOp)forward },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
home(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FastErrorResult rv;
  self->Home(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo home_methodinfo = {
  { (JSJitGetterOp)home },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
updateCommands(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.updateCommands");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  mozilla::dom::Selection* arg1;
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::Selection, mozilla::dom::Selection>(&args[1].toObject(), arg1);
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 2 of Window.updateCommands", "Selection");
          return false;
        }
      }
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of Window.updateCommands");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  int16_t arg2;
  if (args.hasDefined(2)) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[2], &arg2)) {
      return false;
    }
  } else {
    arg2 = 0;
  }
  self->UpdateCommands(NonNullHelper(Constify(arg0)), Constify(arg1), arg2);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo updateCommands_methodinfo = {
  { (JSJitGetterOp)updateCommands },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
find(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg0.Rebind(data, ArrayLength(data) - 1);
  }
  bool arg1;
  if (args.hasDefined(1)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[1], &arg1)) {
      return false;
    }
  } else {
    arg1 = false;
  }
  bool arg2;
  if (args.hasDefined(2)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[2], &arg2)) {
      return false;
    }
  } else {
    arg2 = false;
  }
  bool arg3;
  if (args.hasDefined(3)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[3], &arg3)) {
      return false;
    }
  } else {
    arg3 = false;
  }
  bool arg4;
  if (args.hasDefined(4)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[4], &arg4)) {
      return false;
    }
  } else {
    arg4 = false;
  }
  bool arg5;
  if (args.hasDefined(5)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[5], &arg5)) {
      return false;
    }
  } else {
    arg5 = false;
  }
  bool arg6;
  if (args.hasDefined(6)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[6], &arg6)) {
      return false;
    }
  } else {
    arg6 = false;
  }
  binding_detail::FastErrorResult rv;
  bool result(self->Find(NonNullHelper(Constify(arg0)), arg1, arg2, arg3, arg4, arg5, arg6, rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo find_methodinfo = {
  { (JSJitGetterOp)find },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_mozPaintCount(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  uint64_t result(self->GetMozPaintCount(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo mozPaintCount_getterinfo = {
  { (JSJitGetterOp)get_mozPaintCount },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_MozSelfSupport(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::MozSelfSupport>(self->GetMozSelfSupport(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo MozSelfSupport_getterinfo = {
  { (JSJitGetterOp)get_MozSelfSupport },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwheel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwheel());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwheel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwheel(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwheel_getterinfo = {
  { (JSJitGetterOp)get_onwheel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwheel_setterinfo = {
  { (JSJitGetterOp)set_onwheel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondevicemotion(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndevicemotion());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondevicemotion(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndevicemotion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondevicemotion_getterinfo = {
  { (JSJitGetterOp)get_ondevicemotion },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondevicemotion_setterinfo = {
  { (JSJitGetterOp)set_ondevicemotion },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondeviceorientation(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndeviceorientation());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondeviceorientation(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndeviceorientation(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondeviceorientation_getterinfo = {
  { (JSJitGetterOp)get_ondeviceorientation },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondeviceorientation_setterinfo = {
  { (JSJitGetterOp)set_ondeviceorientation },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onabsolutedeviceorientation(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnabsolutedeviceorientation());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onabsolutedeviceorientation(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnabsolutedeviceorientation(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onabsolutedeviceorientation_getterinfo = {
  { (JSJitGetterOp)get_onabsolutedeviceorientation },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onabsolutedeviceorientation_setterinfo = {
  { (JSJitGetterOp)set_onabsolutedeviceorientation },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondeviceproximity(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndeviceproximity());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondeviceproximity(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndeviceproximity(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondeviceproximity_getterinfo = {
  { (JSJitGetterOp)get_ondeviceproximity },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondeviceproximity_setterinfo = {
  { (JSJitGetterOp)set_ondeviceproximity },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onuserproximity(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnuserproximity());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onuserproximity(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnuserproximity(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onuserproximity_getterinfo = {
  { (JSJitGetterOp)get_onuserproximity },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onuserproximity_setterinfo = {
  { (JSJitGetterOp)set_onuserproximity },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondevicelight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndevicelight());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondevicelight(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndevicelight(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondevicelight_getterinfo = {
  { (JSJitGetterOp)get_ondevicelight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondevicelight_setterinfo = {
  { (JSJitGetterOp)set_ondevicelight },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
dump(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.dump");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  self->Dump(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dump_methodinfo = {
  { (JSJitGetterOp)dump },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
setResizable(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.setResizable");
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  self->SetResizable(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setResizable_methodinfo = {
  { (JSJitGetterOp)setResizable },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
openDialog(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  binding_detail::FakeString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg0.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FakeString arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg1.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::FakeString arg2;
  if (args.hasDefined(2)) {
    if (!ConvertJSValueToString(cx, args[2], eStringify, eStringify, arg2)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    arg2.Rebind(data, ArrayLength(data) - 1);
  }
  binding_detail::AutoSequence<JS::Value> arg3;
  SequenceRooter<JS::Value> arg3_holder(cx, &arg3);
  if (args.length() > 3) {
    if (!arg3.SetCapacity(args.length() - 3, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 3; variadicArg < args.length(); ++variadicArg) {
      JS::Value& slot = *arg3.AppendElement(mozilla::fallible);
      slot = args[variadicArg];
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsPIDOMWindowOuter>(self->OpenDialog(cx, NonNullHelper(Constify(arg0)), NonNullHelper(Constify(arg1)), NonNullHelper(Constify(arg2)), Constify(arg3), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo openDialog_methodinfo = {
  { (JSJitGetterOp)openDialog },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_content(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  self->GetContent(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_content(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "content", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo content_getterinfo = {
  { (JSJitGetterOp)get_content },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo content_setterinfo = {
  { (JSJitGetterOp)set_content },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get__content(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  self->Get_content(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo _content_getterinfo = {
  { (JSJitGetterOp)get__content },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getInterface(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.getInterface");
  }
  nsIJSID* arg0;
  RefPtr<nsIJSID> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<nsIJSID>(source, getter_AddRefs(arg0_holder)))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Window.getInterface", "IID");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.getInterface");
    return false;
  }
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetInterface(cx, NonNullHelper(arg0), &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo getInterface_methodinfo = {
  { (JSJitGetterOp)getInterface },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_windowRoot(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsWindowRoot>(self->GetWindowRoot(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo windowRoot_getterinfo = {
  { (JSJitGetterOp)get_windowRoot },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_isSecureContext(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  bool result(self->IsSecureContext());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo isSecureContext_getterinfo = {
  { (JSJitGetterOp)get_isSecureContext },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_sidebar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  OwningExternalOrWindowProxy result;
  self->GetSidebar(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  SetDocumentAndPageUseCounter(cx, obj, eUseCounter_Window_sidebar_getter);
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_sidebar(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  return JS_DefineProperty(cx, obj, "sidebar", args[0], JSPROP_ENUMERATE);
}

static const JSJitInfo sidebar_getterinfo = {
  { (JSJitGetterOp)get_sidebar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo sidebar_setterinfo = {
  { (JSJitGetterOp)set_sidebar },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onvrdisplayconnect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnvrdisplayconnect());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onvrdisplayconnect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnvrdisplayconnect(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onvrdisplayconnect_getterinfo = {
  { (JSJitGetterOp)get_onvrdisplayconnect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onvrdisplayconnect_setterinfo = {
  { (JSJitGetterOp)set_onvrdisplayconnect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onvrdisplaydisconnect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnvrdisplaydisconnect());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onvrdisplaydisconnect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnvrdisplaydisconnect(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onvrdisplaydisconnect_getterinfo = {
  { (JSJitGetterOp)get_onvrdisplaydisconnect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onvrdisplaydisconnect_setterinfo = {
  { (JSJitGetterOp)set_onvrdisplaydisconnect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onvrdisplaypresentchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnvrdisplaypresentchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onvrdisplaypresentchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnvrdisplaypresentchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onvrdisplaypresentchange_getterinfo = {
  { (JSJitGetterOp)get_onvrdisplaypresentchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onvrdisplaypresentchange_setterinfo = {
  { (JSJitGetterOp)set_onvrdisplaypresentchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_windowState(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  uint16_t result(self->WindowState());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo windowState_getterinfo = {
  { (JSJitGetterOp)get_windowState },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_browserDOMWindow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIBrowserDOMWindow>(self->GetBrowserDOMWindow(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, &NS_GET_IID(nsIBrowserDOMWindow), args.rval())) {
    return false;
  }
  return true;
}

static bool
set_browserDOMWindow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  nsIBrowserDOMWindow* arg0;
  RefPtr<nsIBrowserDOMWindow> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<nsIBrowserDOMWindow>(source, getter_AddRefs(arg0_holder)))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Value being assigned to Window.browserDOMWindow", "nsIBrowserDOMWindow");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Value being assigned to Window.browserDOMWindow");
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->SetBrowserDOMWindow(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo browserDOMWindow_getterinfo = {
  { (JSJitGetterOp)get_browserDOMWindow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo browserDOMWindow_setterinfo = {
  { (JSJitGetterOp)set_browserDOMWindow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getAttention(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  binding_detail::FastErrorResult rv;
  self->GetAttention(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo getAttention_methodinfo = {
  { (JSJitGetterOp)getAttention },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getAttentionWithCycleCount(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.getAttentionWithCycleCount");
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->GetAttentionWithCycleCount(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo getAttentionWithCycleCount_methodinfo = {
  { (JSJitGetterOp)getAttentionWithCycleCount },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
setCursor(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.setCursor");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->SetCursor(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setCursor_methodinfo = {
  { (JSJitGetterOp)setCursor },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
maximize(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  self->Maximize();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo maximize_methodinfo = {
  { (JSJitGetterOp)maximize },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
minimize(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  self->Minimize();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo minimize_methodinfo = {
  { (JSJitGetterOp)minimize },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
restore(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  self->Restore();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo restore_methodinfo = {
  { (JSJitGetterOp)restore },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
notifyDefaultButtonLoaded(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.notifyDefaultButtonLoaded");
  }
  NonNull<mozilla::dom::Element> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Window.notifyDefaultButtonLoaded", "Element");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.notifyDefaultButtonLoaded");
    return false;
  }
  binding_detail::FastErrorResult rv;
  self->NotifyDefaultButtonLoaded(NonNullHelper(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo notifyDefaultButtonLoaded_methodinfo = {
  { (JSJitGetterOp)notifyDefaultButtonLoaded },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_messageManager(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIMessageBroadcaster>(self->GetMessageManager(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, &NS_GET_IID(nsIMessageBroadcaster), args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo messageManager_getterinfo = {
  { (JSJitGetterOp)get_messageManager },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
getGroupMessageManager(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.getGroupMessageManager");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIMessageBroadcaster>(self->GetGroupMessageManager(NonNullHelper(Constify(arg0)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, &NS_GET_IID(nsIMessageBroadcaster), args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo getGroupMessageManager_methodinfo = {
  { (JSJitGetterOp)getGroupMessageManager },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
beginWindowMove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.beginWindowMove");
  }
  NonNull<mozilla::dom::Event> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Event, mozilla::dom::Event>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Window.beginWindowMove", "Event");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Window.beginWindowMove");
    return false;
  }
  mozilla::dom::Element* arg1;
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      {
        nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(&args[1].toObject(), arg1);
        if (NS_FAILED(rv)) {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 2 of Window.beginWindowMove", "Element");
          return false;
        }
      }
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of Window.beginWindowMove");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  binding_detail::FastErrorResult rv;
  self->BeginWindowMove(NonNullHelper(arg0), Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo beginWindowMove_methodinfo = {
  { (JSJitGetterOp)beginWindowMove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_crypto(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Crypto>(self->GetCrypto(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo crypto_getterinfo = {
  { (JSJitGetterOp)get_crypto },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onabort(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnabort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onabort(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnabort(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onabort_getterinfo = {
  { (JSJitGetterOp)get_onabort },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onabort_setterinfo = {
  { (JSJitGetterOp)set_onabort },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onblur(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnblur());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onblur(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnblur(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onblur_getterinfo = {
  { (JSJitGetterOp)get_onblur },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onblur_setterinfo = {
  { (JSJitGetterOp)set_onblur },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onfocus(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnfocus());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onfocus(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnfocus(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onfocus_getterinfo = {
  { (JSJitGetterOp)get_onfocus },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onfocus_setterinfo = {
  { (JSJitGetterOp)set_onfocus },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oncanplay(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOncanplay());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oncanplay(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOncanplay(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oncanplay_getterinfo = {
  { (JSJitGetterOp)get_oncanplay },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oncanplay_setterinfo = {
  { (JSJitGetterOp)set_oncanplay },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oncanplaythrough(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOncanplaythrough());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oncanplaythrough(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOncanplaythrough(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oncanplaythrough_getterinfo = {
  { (JSJitGetterOp)get_oncanplaythrough },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oncanplaythrough_setterinfo = {
  { (JSJitGetterOp)set_oncanplaythrough },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onchange_getterinfo = {
  { (JSJitGetterOp)get_onchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onchange_setterinfo = {
  { (JSJitGetterOp)set_onchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onclick(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnclick());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onclick(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnclick(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onclick_getterinfo = {
  { (JSJitGetterOp)get_onclick },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onclick_setterinfo = {
  { (JSJitGetterOp)set_onclick },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oncontextmenu(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOncontextmenu());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oncontextmenu(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOncontextmenu(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oncontextmenu_getterinfo = {
  { (JSJitGetterOp)get_oncontextmenu },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oncontextmenu_setterinfo = {
  { (JSJitGetterOp)set_oncontextmenu },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondblclick(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndblclick());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondblclick(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndblclick(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondblclick_getterinfo = {
  { (JSJitGetterOp)get_ondblclick },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondblclick_setterinfo = {
  { (JSJitGetterOp)set_ondblclick },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondrag(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndrag());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondrag(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndrag(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondrag_getterinfo = {
  { (JSJitGetterOp)get_ondrag },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondrag_setterinfo = {
  { (JSJitGetterOp)set_ondrag },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragend_getterinfo = {
  { (JSJitGetterOp)get_ondragend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragend_setterinfo = {
  { (JSJitGetterOp)set_ondragend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragenter());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragenter(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragenter_getterinfo = {
  { (JSJitGetterOp)get_ondragenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragenter_setterinfo = {
  { (JSJitGetterOp)set_ondragenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragexit(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragexit());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragexit(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragexit(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragexit_getterinfo = {
  { (JSJitGetterOp)get_ondragexit },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragexit_setterinfo = {
  { (JSJitGetterOp)set_ondragexit },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragleave());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragleave(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragleave_getterinfo = {
  { (JSJitGetterOp)get_ondragleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragleave_setterinfo = {
  { (JSJitGetterOp)set_ondragleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragover());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragover(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragover_getterinfo = {
  { (JSJitGetterOp)get_ondragover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragover_setterinfo = {
  { (JSJitGetterOp)set_ondragover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondragstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndragstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondragstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndragstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondragstart_getterinfo = {
  { (JSJitGetterOp)get_ondragstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondragstart_setterinfo = {
  { (JSJitGetterOp)set_ondragstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondrop(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndrop());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondrop(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndrop(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondrop_getterinfo = {
  { (JSJitGetterOp)get_ondrop },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondrop_setterinfo = {
  { (JSJitGetterOp)set_ondrop },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ondurationchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOndurationchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondurationchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOndurationchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondurationchange_getterinfo = {
  { (JSJitGetterOp)get_ondurationchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ondurationchange_setterinfo = {
  { (JSJitGetterOp)set_ondurationchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onemptied(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnemptied());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onemptied(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnemptied(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onemptied_getterinfo = {
  { (JSJitGetterOp)get_onemptied },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onemptied_setterinfo = {
  { (JSJitGetterOp)set_onemptied },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onended(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnended());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onended(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnended(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onended_getterinfo = {
  { (JSJitGetterOp)get_onended },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onended_setterinfo = {
  { (JSJitGetterOp)set_onended },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oninput(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOninput());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oninput(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOninput(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oninput_getterinfo = {
  { (JSJitGetterOp)get_oninput },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oninput_setterinfo = {
  { (JSJitGetterOp)set_oninput },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_oninvalid(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOninvalid());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oninvalid(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOninvalid(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oninvalid_getterinfo = {
  { (JSJitGetterOp)get_oninvalid },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo oninvalid_setterinfo = {
  { (JSJitGetterOp)set_oninvalid },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onkeydown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnkeydown());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onkeydown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnkeydown(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onkeydown_getterinfo = {
  { (JSJitGetterOp)get_onkeydown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onkeydown_setterinfo = {
  { (JSJitGetterOp)set_onkeydown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onkeypress(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnkeypress());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onkeypress(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnkeypress(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onkeypress_getterinfo = {
  { (JSJitGetterOp)get_onkeypress },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onkeypress_setterinfo = {
  { (JSJitGetterOp)set_onkeypress },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onkeyup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnkeyup());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onkeyup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnkeyup(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onkeyup_getterinfo = {
  { (JSJitGetterOp)get_onkeyup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onkeyup_setterinfo = {
  { (JSJitGetterOp)set_onkeyup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnload());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnload(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onload_getterinfo = {
  { (JSJitGetterOp)get_onload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onload_setterinfo = {
  { (JSJitGetterOp)set_onload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onloadeddata(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnloadeddata());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onloadeddata(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnloadeddata(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onloadeddata_getterinfo = {
  { (JSJitGetterOp)get_onloadeddata },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onloadeddata_setterinfo = {
  { (JSJitGetterOp)set_onloadeddata },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onloadedmetadata(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnloadedmetadata());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onloadedmetadata(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnloadedmetadata(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onloadedmetadata_getterinfo = {
  { (JSJitGetterOp)get_onloadedmetadata },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onloadedmetadata_setterinfo = {
  { (JSJitGetterOp)set_onloadedmetadata },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onloadend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnloadend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onloadend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnloadend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onloadend_getterinfo = {
  { (JSJitGetterOp)get_onloadend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onloadend_setterinfo = {
  { (JSJitGetterOp)set_onloadend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onloadstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnloadstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onloadstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnloadstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onloadstart_getterinfo = {
  { (JSJitGetterOp)get_onloadstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onloadstart_setterinfo = {
  { (JSJitGetterOp)set_onloadstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmousedown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmousedown());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmousedown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmousedown(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmousedown_getterinfo = {
  { (JSJitGetterOp)get_onmousedown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmousedown_setterinfo = {
  { (JSJitGetterOp)set_onmousedown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmouseenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmouseenter());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmouseenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmouseenter(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmouseenter_getterinfo = {
  { (JSJitGetterOp)get_onmouseenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmouseenter_setterinfo = {
  { (JSJitGetterOp)set_onmouseenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmouseleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmouseleave());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmouseleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmouseleave(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmouseleave_getterinfo = {
  { (JSJitGetterOp)get_onmouseleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmouseleave_setterinfo = {
  { (JSJitGetterOp)set_onmouseleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmousemove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmousemove());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmousemove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmousemove(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmousemove_getterinfo = {
  { (JSJitGetterOp)get_onmousemove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmousemove_setterinfo = {
  { (JSJitGetterOp)set_onmousemove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmouseout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmouseout());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmouseout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmouseout(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmouseout_getterinfo = {
  { (JSJitGetterOp)get_onmouseout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmouseout_setterinfo = {
  { (JSJitGetterOp)set_onmouseout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmouseover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmouseover());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmouseover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmouseover(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmouseover_getterinfo = {
  { (JSJitGetterOp)get_onmouseover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmouseover_setterinfo = {
  { (JSJitGetterOp)set_onmouseover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmouseup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmouseup());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmouseup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmouseup(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmouseup_getterinfo = {
  { (JSJitGetterOp)get_onmouseup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmouseup_setterinfo = {
  { (JSJitGetterOp)set_onmouseup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpause(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpause());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpause(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpause(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpause_getterinfo = {
  { (JSJitGetterOp)get_onpause },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpause_setterinfo = {
  { (JSJitGetterOp)set_onpause },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onplay(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnplay());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onplay(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnplay(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onplay_getterinfo = {
  { (JSJitGetterOp)get_onplay },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onplay_setterinfo = {
  { (JSJitGetterOp)set_onplay },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onplaying(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnplaying());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onplaying(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnplaying(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onplaying_getterinfo = {
  { (JSJitGetterOp)get_onplaying },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onplaying_setterinfo = {
  { (JSJitGetterOp)set_onplaying },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onprogress(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnprogress());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onprogress(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnprogress(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onprogress_getterinfo = {
  { (JSJitGetterOp)get_onprogress },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onprogress_setterinfo = {
  { (JSJitGetterOp)set_onprogress },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onratechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnratechange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onratechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnratechange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onratechange_getterinfo = {
  { (JSJitGetterOp)get_onratechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onratechange_setterinfo = {
  { (JSJitGetterOp)set_onratechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onreset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnreset());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onreset(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnreset(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onreset_getterinfo = {
  { (JSJitGetterOp)get_onreset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onreset_setterinfo = {
  { (JSJitGetterOp)set_onreset },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onresize(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnresize());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onresize(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnresize(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onresize_getterinfo = {
  { (JSJitGetterOp)get_onresize },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onresize_setterinfo = {
  { (JSJitGetterOp)set_onresize },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onscroll(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnscroll());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onscroll(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnscroll(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onscroll_getterinfo = {
  { (JSJitGetterOp)get_onscroll },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onscroll_setterinfo = {
  { (JSJitGetterOp)set_onscroll },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onseeked(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnseeked());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onseeked(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnseeked(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onseeked_getterinfo = {
  { (JSJitGetterOp)get_onseeked },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onseeked_setterinfo = {
  { (JSJitGetterOp)set_onseeked },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onseeking(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnseeking());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onseeking(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnseeking(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onseeking_getterinfo = {
  { (JSJitGetterOp)get_onseeking },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onseeking_setterinfo = {
  { (JSJitGetterOp)set_onseeking },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onselect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnselect());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onselect(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnselect(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onselect_getterinfo = {
  { (JSJitGetterOp)get_onselect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onselect_setterinfo = {
  { (JSJitGetterOp)set_onselect },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onshow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnshow());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onshow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnshow(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onshow_getterinfo = {
  { (JSJitGetterOp)get_onshow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onshow_setterinfo = {
  { (JSJitGetterOp)set_onshow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onstalled(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnstalled());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onstalled(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnstalled(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onstalled_getterinfo = {
  { (JSJitGetterOp)get_onstalled },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onstalled_setterinfo = {
  { (JSJitGetterOp)set_onstalled },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onsubmit(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnsubmit());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onsubmit(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnsubmit(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onsubmit_getterinfo = {
  { (JSJitGetterOp)get_onsubmit },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onsubmit_setterinfo = {
  { (JSJitGetterOp)set_onsubmit },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onsuspend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnsuspend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onsuspend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnsuspend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onsuspend_getterinfo = {
  { (JSJitGetterOp)get_onsuspend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onsuspend_setterinfo = {
  { (JSJitGetterOp)set_onsuspend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontimeupdate(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntimeupdate());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontimeupdate(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntimeupdate(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontimeupdate_getterinfo = {
  { (JSJitGetterOp)get_ontimeupdate },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontimeupdate_setterinfo = {
  { (JSJitGetterOp)set_ontimeupdate },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onvolumechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnvolumechange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onvolumechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnvolumechange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onvolumechange_getterinfo = {
  { (JSJitGetterOp)get_onvolumechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onvolumechange_setterinfo = {
  { (JSJitGetterOp)set_onvolumechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwaiting(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwaiting());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwaiting(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwaiting(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwaiting_getterinfo = {
  { (JSJitGetterOp)get_onwaiting },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwaiting_setterinfo = {
  { (JSJitGetterOp)set_onwaiting },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onselectstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnselectstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onselectstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnselectstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onselectstart_getterinfo = {
  { (JSJitGetterOp)get_onselectstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onselectstart_setterinfo = {
  { (JSJitGetterOp)set_onselectstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontoggle(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntoggle());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontoggle(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntoggle(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontoggle_getterinfo = {
  { (JSJitGetterOp)get_ontoggle },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontoggle_setterinfo = {
  { (JSJitGetterOp)set_ontoggle },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointercancel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointercancel());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointercancel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointercancel(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointercancel_getterinfo = {
  { (JSJitGetterOp)get_onpointercancel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointercancel_setterinfo = {
  { (JSJitGetterOp)set_onpointercancel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerdown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerdown());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerdown(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerdown(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerdown_getterinfo = {
  { (JSJitGetterOp)get_onpointerdown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerdown_setterinfo = {
  { (JSJitGetterOp)set_onpointerdown },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerup());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerup(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerup(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerup_getterinfo = {
  { (JSJitGetterOp)get_onpointerup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerup_setterinfo = {
  { (JSJitGetterOp)set_onpointerup },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointermove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointermove());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointermove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointermove(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointermove_getterinfo = {
  { (JSJitGetterOp)get_onpointermove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointermove_setterinfo = {
  { (JSJitGetterOp)set_onpointermove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerout());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerout(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerout_getterinfo = {
  { (JSJitGetterOp)get_onpointerout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerout_setterinfo = {
  { (JSJitGetterOp)set_onpointerout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerover());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerover(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerover(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerover_getterinfo = {
  { (JSJitGetterOp)get_onpointerover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerover_setterinfo = {
  { (JSJitGetterOp)set_onpointerover },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerenter());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerenter(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerenter(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerenter_getterinfo = {
  { (JSJitGetterOp)get_onpointerenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerenter_setterinfo = {
  { (JSJitGetterOp)set_onpointerenter },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpointerleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpointerleave());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpointerleave(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpointerleave(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpointerleave_getterinfo = {
  { (JSJitGetterOp)get_onpointerleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpointerleave_setterinfo = {
  { (JSJitGetterOp)set_onpointerleave },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ongotpointercapture(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOngotpointercapture());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ongotpointercapture(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOngotpointercapture(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ongotpointercapture_getterinfo = {
  { (JSJitGetterOp)get_ongotpointercapture },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ongotpointercapture_setterinfo = {
  { (JSJitGetterOp)set_ongotpointercapture },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onlostpointercapture(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnlostpointercapture());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onlostpointercapture(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnlostpointercapture(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onlostpointercapture_getterinfo = {
  { (JSJitGetterOp)get_onlostpointercapture },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onlostpointercapture_setterinfo = {
  { (JSJitGetterOp)set_onlostpointercapture },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmozfullscreenchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmozfullscreenchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmozfullscreenchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmozfullscreenchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmozfullscreenchange_getterinfo = {
  { (JSJitGetterOp)get_onmozfullscreenchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmozfullscreenchange_setterinfo = {
  { (JSJitGetterOp)set_onmozfullscreenchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmozfullscreenerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmozfullscreenerror());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmozfullscreenerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmozfullscreenerror(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmozfullscreenerror_getterinfo = {
  { (JSJitGetterOp)get_onmozfullscreenerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmozfullscreenerror_setterinfo = {
  { (JSJitGetterOp)set_onmozfullscreenerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmozpointerlockchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmozpointerlockchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmozpointerlockchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmozpointerlockchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmozpointerlockchange_getterinfo = {
  { (JSJitGetterOp)get_onmozpointerlockchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmozpointerlockchange_setterinfo = {
  { (JSJitGetterOp)set_onmozpointerlockchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmozpointerlockerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmozpointerlockerror());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmozpointerlockerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmozpointerlockerror(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmozpointerlockerror_getterinfo = {
  { (JSJitGetterOp)get_onmozpointerlockerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmozpointerlockerror_setterinfo = {
  { (JSJitGetterOp)set_onmozpointerlockerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onanimationend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnanimationend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onanimationend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnanimationend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onanimationend_getterinfo = {
  { (JSJitGetterOp)get_onanimationend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onanimationend_setterinfo = {
  { (JSJitGetterOp)set_onanimationend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onanimationiteration(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnanimationiteration());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onanimationiteration(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnanimationiteration(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onanimationiteration_getterinfo = {
  { (JSJitGetterOp)get_onanimationiteration },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onanimationiteration_setterinfo = {
  { (JSJitGetterOp)set_onanimationiteration },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onanimationstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnanimationstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onanimationstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnanimationstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onanimationstart_getterinfo = {
  { (JSJitGetterOp)get_onanimationstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onanimationstart_setterinfo = {
  { (JSJitGetterOp)set_onanimationstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontransitionend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntransitionend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontransitionend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntransitionend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontransitionend_getterinfo = {
  { (JSJitGetterOp)get_ontransitionend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontransitionend_setterinfo = {
  { (JSJitGetterOp)set_ontransitionend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwebkitanimationend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwebkitanimationend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwebkitanimationend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwebkitanimationend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwebkitanimationend_getterinfo = {
  { (JSJitGetterOp)get_onwebkitanimationend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwebkitanimationend_setterinfo = {
  { (JSJitGetterOp)set_onwebkitanimationend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwebkitanimationiteration(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwebkitanimationiteration());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwebkitanimationiteration(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwebkitanimationiteration(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwebkitanimationiteration_getterinfo = {
  { (JSJitGetterOp)get_onwebkitanimationiteration },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwebkitanimationiteration_setterinfo = {
  { (JSJitGetterOp)set_onwebkitanimationiteration },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwebkitanimationstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwebkitanimationstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwebkitanimationstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwebkitanimationstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwebkitanimationstart_getterinfo = {
  { (JSJitGetterOp)get_onwebkitanimationstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwebkitanimationstart_setterinfo = {
  { (JSJitGetterOp)set_onwebkitanimationstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onwebkittransitionend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnwebkittransitionend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onwebkittransitionend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnwebkittransitionend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onwebkittransitionend_getterinfo = {
  { (JSJitGetterOp)get_onwebkittransitionend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onwebkittransitionend_setterinfo = {
  { (JSJitGetterOp)set_onwebkittransitionend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
fetch(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.fetch");
  }
  RequestOrUSVString arg0;
  RequestOrUSVStringArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToRequest(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (0);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Argument 1 of Window.fetch", "Request");
      return false;
    }
  }
  RootedDictionary<binding_detail::FastRequestInit> arg1(cx);
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue,  "Argument 2 of Window.fetch", false)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::Promise>(self->Fetch(Constify(arg0), Constify(arg1), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
fetch_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = fetch(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo fetch_methodinfo = {
  { (JSJitGetterOp)fetch_promiseWrapper },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_u2f(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::U2F>(self->GetU2f(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo u2f_getterinfo = {
  { (JSJitGetterOp)get_u2f },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_indexedDB(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::IDBFactory>(self->GetIndexedDB(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo indexedDB_getterinfo = {
  { (JSJitGetterOp)get_indexedDB },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
createImageBitmap(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 5u);
  switch (argcount) {
    case 1: {
      HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer arg0;
      HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBufferArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToBlob(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageData(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToCanvasRenderingContext2D(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToArrayBufferView(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Argument 1 of Window.createImageBitmap", "HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, Blob, ImageData, CanvasRenderingContext2D, ImageBitmap, ArrayBufferView, ArrayBuffer");
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::Promise>(self->CreateImageBitmap(Constify(arg0), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 5: {
      HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBuffer arg0;
      HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrCanvasRenderingContext2DOrImageBitmapOrArrayBufferViewOrArrayBufferArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToBlob(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageData(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToCanvasRenderingContext2D(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToArrayBufferView(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Argument 1 of Window.createImageBitmap", "HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, Blob, ImageData, CanvasRenderingContext2D, ImageBitmap, ArrayBufferView, ArrayBuffer");
          return false;
        }
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
        return false;
      }
      int32_t arg2;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[2], &arg2)) {
        return false;
      }
      if (args[3].isNumber()) {
        int32_t arg3;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[3], &arg3)) {
          return false;
        }
        int32_t arg4;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[4], &arg4)) {
          return false;
        }
        binding_detail::FastErrorResult rv;
        auto result(StrongOrRawPtr<mozilla::dom::Promise>(self->CreateImageBitmap(Constify(arg0), arg1, arg2, arg3, arg4, rv)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      ImageBitmapFormat arg3;
      {
        bool ok;
        int index = FindEnumStringIndex<true>(cx, args[3], ImageBitmapFormatValues::strings, "ImageBitmapFormat", "Argument 4 of Window.createImageBitmap", &ok);
        if (!ok) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg3 = static_cast<ImageBitmapFormat>(index);
      }
      binding_detail::AutoSequence<ChannelPixelLayout> arg4;
      if (args[4].isObject()) {
        JS::ForOfIterator iter(cx);
        if (!iter.init(args[4], JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter.valueIsIterable()) {
          ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Argument 5 of Window.createImageBitmap");
          return false;
        }
        binding_detail::AutoSequence<ChannelPixelLayout> &arr = arg4;
        JS::Rooted<JS::Value> temp(cx);
        while (true) {
          bool done;
          if (!iter.next(&temp, &done)) {
            return false;
          }
          if (done) {
            break;
          }
          ChannelPixelLayout* slotPtr = arr.AppendElement(mozilla::fallible);
          if (!slotPtr) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          ChannelPixelLayout& slot = *slotPtr;
          if (!slot.Init(cx, temp,  "Element of argument 5 of Window.createImageBitmap", false)) {
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Argument 5 of Window.createImageBitmap");
        return false;
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::Promise>(self->CreateImageBitmap(Constify(arg0), arg1, arg2, arg3, Constify(arg4), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.createImageBitmap");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
createImageBitmap_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = createImageBitmap(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo createImageBitmap_methodinfo = {
  { (JSJitGetterOp)createImageBitmap_promiseWrapper },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<OnErrorEventHandlerNonNull> result(self->GetOnerror());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onerror(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastOnErrorEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastOnErrorEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnerror(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onerror_getterinfo = {
  { (JSJitGetterOp)get_onerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onerror_setterinfo = {
  { (JSJitGetterOp)set_onerror },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_speechSynthesis(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::SpeechSynthesis>(self->GetSpeechSynthesis(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo speechSynthesis_getterinfo = {
  { (JSJitGetterOp)get_speechSynthesis },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontouchstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntouchstart());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontouchstart(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntouchstart(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontouchstart_getterinfo = {
  { (JSJitGetterOp)get_ontouchstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontouchstart_setterinfo = {
  { (JSJitGetterOp)set_ontouchstart },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontouchend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntouchend());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontouchend(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntouchend(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontouchend_getterinfo = {
  { (JSJitGetterOp)get_ontouchend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontouchend_setterinfo = {
  { (JSJitGetterOp)set_ontouchend },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontouchmove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntouchmove());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontouchmove(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntouchmove(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontouchmove_getterinfo = {
  { (JSJitGetterOp)get_ontouchmove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontouchmove_setterinfo = {
  { (JSJitGetterOp)set_ontouchmove },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ontouchcancel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOntouchcancel());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontouchcancel(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOntouchcancel(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontouchcancel_getterinfo = {
  { (JSJitGetterOp)get_ontouchcancel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ontouchcancel_setterinfo = {
  { (JSJitGetterOp)set_ontouchcancel },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
btoa(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.btoa");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->Btoa(NonNullHelper(Constify(arg0)), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo btoa_methodinfo = {
  { (JSJitGetterOp)btoa },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
atob(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.atob");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->Atob(NonNullHelper(Constify(arg0)), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo atob_methodinfo = {
  { (JSJitGetterOp)atob },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onafterprint(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnafterprint());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onafterprint(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnafterprint(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onafterprint_getterinfo = {
  { (JSJitGetterOp)get_onafterprint },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onafterprint_setterinfo = {
  { (JSJitGetterOp)set_onafterprint },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onbeforeprint(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnbeforeprint());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onbeforeprint(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnbeforeprint(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onbeforeprint_getterinfo = {
  { (JSJitGetterOp)get_onbeforeprint },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onbeforeprint_setterinfo = {
  { (JSJitGetterOp)set_onbeforeprint },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onbeforeunload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<OnBeforeUnloadEventHandlerNonNull> result(self->GetOnbeforeunload());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onbeforeunload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastOnBeforeUnloadEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastOnBeforeUnloadEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnbeforeunload(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onbeforeunload_getterinfo = {
  { (JSJitGetterOp)get_onbeforeunload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onbeforeunload_setterinfo = {
  { (JSJitGetterOp)set_onbeforeunload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onhashchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnhashchange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onhashchange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnhashchange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onhashchange_getterinfo = {
  { (JSJitGetterOp)get_onhashchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onhashchange_setterinfo = {
  { (JSJitGetterOp)set_onhashchange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onlanguagechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnlanguagechange());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onlanguagechange(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnlanguagechange(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onlanguagechange_getterinfo = {
  { (JSJitGetterOp)get_onlanguagechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onlanguagechange_setterinfo = {
  { (JSJitGetterOp)set_onlanguagechange },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onmessage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnmessage());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onmessage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnmessage(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onmessage_getterinfo = {
  { (JSJitGetterOp)get_onmessage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onmessage_setterinfo = {
  { (JSJitGetterOp)set_onmessage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onoffline(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnoffline());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onoffline(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnoffline(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onoffline_getterinfo = {
  { (JSJitGetterOp)get_onoffline },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onoffline_setterinfo = {
  { (JSJitGetterOp)set_onoffline },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_ononline(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnonline());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ononline(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnonline(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ononline_getterinfo = {
  { (JSJitGetterOp)get_ononline },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo ononline_setterinfo = {
  { (JSJitGetterOp)set_ononline },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpagehide(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpagehide());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpagehide(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpagehide(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpagehide_getterinfo = {
  { (JSJitGetterOp)get_onpagehide },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpagehide_setterinfo = {
  { (JSJitGetterOp)set_onpagehide },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpageshow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpageshow());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpageshow(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpageshow(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpageshow_getterinfo = {
  { (JSJitGetterOp)get_onpageshow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpageshow_setterinfo = {
  { (JSJitGetterOp)set_onpageshow },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onpopstate(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnpopstate());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onpopstate(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnpopstate(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onpopstate_getterinfo = {
  { (JSJitGetterOp)get_onpopstate },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onpopstate_setterinfo = {
  { (JSJitGetterOp)set_onpopstate },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onstorage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnstorage());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onstorage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnstorage(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onstorage_getterinfo = {
  { (JSJitGetterOp)get_onstorage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onstorage_setterinfo = {
  { (JSJitGetterOp)set_onstorage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_onunload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  RefPtr<EventHandlerNonNull> result(self->GetOnunload());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onunload(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  self->SetOnunload(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onunload_getterinfo = {
  { (JSJitGetterOp)get_onunload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo onunload_setterinfo = {
  { (JSJitGetterOp)set_onunload },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_localStorage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::DOMStorage>(self->GetLocalStorage(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo localStorage_getterinfo = {
  { (JSJitGetterOp)get_localStorage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_dialogArguments(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetDialogArguments(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo dialogArguments_getterinfo = {
  { (JSJitGetterOp)get_dialogArguments },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_returnValue(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetReturnValue(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_returnValue(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitSetterCallArgs args)
{
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  binding_detail::FastErrorResult rv;
  self->SetReturnValue(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo returnValue_getterinfo = {
  { (JSJitGetterOp)get_returnValue },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");
static const JSJitInfo returnValue_setterinfo = {
  { (JSJitGetterOp)set_returnValue },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
get_sessionStorage(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, JSJitGetterCallArgs args)
{
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::DOMStorage>(self->GetSessionStorage(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo sessionStorage_getterinfo = {
  { (JSJitGetterOp)get_sessionStorage },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

//MODI_FY
static bool
test(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args){
  return true;
}

static const JSJitInfo test_methodinfo = {
  { (JSJitGetterOp)test },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
//MODI_FY

static bool
setTimeout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 1: {
      MOZ_FALLTHROUGH;
    }
    case 2: {
      MOZ_FALLTHROUGH;
    }
    case 3: {
      if (args[0].isObject()) {
        do {
          RootedCallback<OwningNonNull<binding_detail::FastFunction>> arg0(cx);
          if (JS::IsCallable(&args[0].toObject())) {
            { // Scope for tempRoot
              JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
              arg0 = new binding_detail::FastFunction(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
            }
          } else {
            break;
          }
          int32_t arg1;
          if (args.hasDefined(1)) {
            if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
              return false;
            }
          } else {
            arg1 = 0;
          }
          binding_detail::AutoSequence<JS::Value> arg2;
          SequenceRooter<JS::Value> arg2_holder(cx, &arg2);
          if (args.length() > 2) {
            if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
              JS::Value& slot = *arg2.AppendElement(mozilla::fallible);
              slot = args[variadicArg];
            }
          }
          binding_detail::FastErrorResult rv;
          int32_t result(self->SetTimeout(cx, NonNullHelper(arg0), arg1, Constify(arg2), rv));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setInt32(int32_t(result));
          return true;
        } while (0);
      }
      binding_detail::FakeString arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      int32_t arg1;
      if (args.hasDefined(1)) {
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1)) {
          return false;
        }
      } else {
        arg1 = 0;
      }
      binding_detail::AutoSequence<JS::Value> arg2;
      SequenceRooter<JS::Value> arg2_holder(cx, &arg2);
      if (args.length() > 2) {
        if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
          JS::Value& slot = *arg2.AppendElement(mozilla::fallible);
          slot = args[variadicArg];
        }
      }
      binding_detail::FastErrorResult rv;
      int32_t result(self->SetTimeout(cx, NonNullHelper(Constify(arg0)), arg1, Constify(arg2), rv));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setInt32(int32_t(result));
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.setTimeout");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo setTimeout_methodinfo = {
  { (JSJitGetterOp)setTimeout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
clearTimeout(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  int32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  self->ClearTimeout(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo clearTimeout_methodinfo = {
  { (JSJitGetterOp)clearTimeout },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
setInterval(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 1: {
      MOZ_FALLTHROUGH;
    }
    case 2: {
      MOZ_FALLTHROUGH;
    }
    case 3: {
      if (args[0].isObject()) {
        do {
          RootedCallback<OwningNonNull<binding_detail::FastFunction>> arg0(cx);
          if (JS::IsCallable(&args[0].toObject())) {
            { // Scope for tempRoot
              JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
              arg0 = new binding_detail::FastFunction(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
            }
          } else {
            break;
          }
          Optional<int32_t> arg1;
          if (args.hasDefined(1)) {
            arg1.Construct();
            if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1.Value())) {
              return false;
            }
          }
          binding_detail::AutoSequence<JS::Value> arg2;
          SequenceRooter<JS::Value> arg2_holder(cx, &arg2);
          if (args.length() > 2) {
            if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
              JS::Value& slot = *arg2.AppendElement(mozilla::fallible);
              slot = args[variadicArg];
            }
          }
          binding_detail::FastErrorResult rv;
          int32_t result(self->SetInterval(cx, NonNullHelper(arg0), Constify(arg1), Constify(arg2), rv));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setInt32(int32_t(result));
          return true;
        } while (0);
      }
      binding_detail::FakeString arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Optional<int32_t> arg1;
      if (args.hasDefined(1)) {
        arg1.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], &arg1.Value())) {
          return false;
        }
      }
      binding_detail::AutoSequence<JS::Value> arg2;
      SequenceRooter<JS::Value> arg2_holder(cx, &arg2);
      if (args.length() > 2) {
        if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
          JS::Value& slot = *arg2.AppendElement(mozilla::fallible);
          slot = args[variadicArg];
        }
      }
      binding_detail::FastErrorResult rv;
      int32_t result(self->SetInterval(cx, NonNullHelper(Constify(arg0)), Constify(arg1), Constify(arg2), rv));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setInt32(int32_t(result));
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window.setInterval");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo setInterval_methodinfo = {
  { (JSJitGetterOp)setInterval },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
clearInterval(JSContext* cx, JS::Handle<JSObject*> obj, nsGlobalWindow* self, const JSJitMethodCallArgs& args)
{
  int32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  self->ClearInterval(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo clearInterval_methodinfo = {
  { (JSJitGetterOp)clearInterval },
  { prototypes::id::Window },
  { PrototypeTraits<prototypes::id::Window>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 5, "There is no slot for us");

static bool
genericMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Method);
  JSJitMethodOp method = info->method;
  bool ok = method(cx, obj, self, JSJitMethodCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}

static bool
genericPromiseReturningMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  // Make sure to save the callee before someone maybe messes with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    ThrowInvalidThis(cx, args, false, "Window");

    return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                     args.rval());
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");

      return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                       args.rval());
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Method);
  JSJitMethodOp method = info->method;
  bool ok = method(cx, obj, self, JSJitMethodCallArgs(args));
  if (ok) {
#ifdef DEBUG
    AssertReturnTypeMatchesJitinfo(info, args.rval());
#endif
    return true;
  }

  MOZ_ASSERT(info->returnType() == JSVAL_TYPE_OBJECT);
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static bool
genericCrossOriginMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    JS::Rooted<JSObject*> maybeUncheckedObj(cx);
    if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
      maybeUncheckedObj = js::UncheckedUnwrap(obj);
    } else {
      maybeUncheckedObj = js::CheckedUnwrap(obj);
      if (!maybeUncheckedObj) {
        return ThrowInvalidThis(cx, args, true, "Window");
      }
    }
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(maybeUncheckedObj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Method);
  JSJitMethodOp method = info->method;
  bool ok = method(cx, obj, self, JSJitMethodCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}

static bool
genericGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Getter);
  JSJitGetterOp getter = info->getter;
  bool ok = getter(cx, obj, self, JSJitGetterCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}

static bool
genericLenientGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    if (!ReportLenientThisUnwrappingFailure(cx, &args.callee())) {
      return false;
    }
    args.rval().set(JS::UndefinedValue());
    return true;
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ReportLenientThisUnwrappingFailure(cx, &args.callee())) {
        return false;
      }
      args.rval().set(JS::UndefinedValue());
      return true;
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Getter);
  JSJitGetterOp getter = info->getter;
  bool ok = getter(cx, obj, self, JSJitGetterCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}

static bool
genericCrossOriginGetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    JS::Rooted<JSObject*> maybeUncheckedObj(cx);
    if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
      maybeUncheckedObj = js::UncheckedUnwrap(obj);
    } else {
      maybeUncheckedObj = js::CheckedUnwrap(obj);
      if (!maybeUncheckedObj) {
        return ThrowInvalidThis(cx, args, true, "Window");
      }
    }
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(maybeUncheckedObj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Getter);
  JSJitGetterOp getter = info->getter;
  bool ok = getter(cx, obj, self, JSJitGetterCallArgs(args));
#ifdef DEBUG
  if (ok) {
    AssertReturnTypeMatchesJitinfo(info, args.rval());
  }
#endif
  return ok;
}

static bool
genericSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  if (args.length() == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window attribute setter");
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Setter);
  JSJitSetterOp setter = info->setter;
  if (!setter(cx, obj, self, JSJitSetterCallArgs(args))) {
    return false;
  }
  args.rval().setUndefined();
#ifdef DEBUG
  AssertReturnTypeMatchesJitinfo(info, args.rval());
#endif
  return true;
}

static bool
genericLenientSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    if (!ReportLenientThisUnwrappingFailure(cx, &args.callee())) {
      return false;
    }
    args.rval().set(JS::UndefinedValue());
    return true;
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ReportLenientThisUnwrappingFailure(cx, &args.callee())) {
        return false;
      }
      args.rval().set(JS::UndefinedValue());
      return true;
    }
  }
  if (args.length() == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window attribute setter");
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Setter);
  JSJitSetterOp setter = info->setter;
  if (!setter(cx, obj, self, JSJitSetterCallArgs(args))) {
    return false;
  }
  args.rval().setUndefined();
#ifdef DEBUG
  AssertReturnTypeMatchesJitinfo(info, args.rval());
#endif
  return true;
}

static bool
genericCrossOriginSetter(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.thisv().isNullOrUndefined() && !args.thisv().isObject()) {
    return ThrowInvalidThis(cx, args, false, "Window");
  }
  JS::Rooted<JSObject*> obj(cx, args.thisv().isObject() ? &args.thisv().toObject() : js::GetGlobalForObjectCrossCompartment(&args.callee()));

  nsGlobalWindow* self;
  {
    JS::Rooted<JSObject*> maybeUncheckedObj(cx);
    if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
      maybeUncheckedObj = js::UncheckedUnwrap(obj);
    } else {
      maybeUncheckedObj = js::CheckedUnwrap(obj);
      if (!maybeUncheckedObj) {
        return ThrowInvalidThis(cx, args, true, "Window");
      }
    }
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(maybeUncheckedObj, self);
    if (NS_FAILED(rv)) {
      return ThrowInvalidThis(cx, args, rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO, "Window");
    }
  }
  if (args.length() == 0) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Window attribute setter");
  }
  const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(args.calleev());
  MOZ_ASSERT(info->type() == JSJitInfo::Setter);
  JSJitSetterOp setter = info->setter;
  if (!setter(cx, obj, self, JSJitSetterCallArgs(args))) {
    return false;
  }
  args.rval().setUndefined();
#ifdef DEBUG
  AssertReturnTypeMatchesJitinfo(info, args.rval());
#endif
  return true;
}

static void
_finalize(js::FreeOp* fop, JSObject* obj)
{
  nsGlobalWindow* self = UnwrapPossiblyNotInitializedDOMObject<nsGlobalWindow>(obj);
  if (self) {
    ClearWrapper(self, self);
    mozilla::dom::FinalizeGlobal(CastToJSFreeOp(fop), obj);
    AddForDeferredFinalization<nsGlobalWindow>(self);
  }
}

static void
_objectMoved(JSObject* obj, const JSObject* old)
{
  nsGlobalWindow* self = UnwrapPossiblyNotInitializedDOMObject<nsGlobalWindow>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }
}

static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("close", genericCrossOriginMethod, reinterpret_cast<const JSJitInfo*>(&close_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("stop", genericMethod, reinterpret_cast<const JSJitInfo*>(&stop_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("focus", genericCrossOriginMethod, reinterpret_cast<const JSJitInfo*>(&focus_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("blur", genericCrossOriginMethod, reinterpret_cast<const JSJitInfo*>(&blur_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("open", genericMethod, reinterpret_cast<const JSJitInfo*>(&open_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("alert", genericMethod, reinterpret_cast<const JSJitInfo*>(&alert_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("confirm", genericMethod, reinterpret_cast<const JSJitInfo*>(&confirm_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prompt", genericMethod, reinterpret_cast<const JSJitInfo*>(&prompt_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("print", genericMethod, reinterpret_cast<const JSJitInfo*>(&print_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("showModalDialog", genericMethod, reinterpret_cast<const JSJitInfo*>(&showModalDialog_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("postMessage", genericCrossOriginMethod, reinterpret_cast<const JSJitInfo*>(&postMessage_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("captureEvents", genericMethod, reinterpret_cast<const JSJitInfo*>(&captureEvents_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("releaseEvents", genericMethod, reinterpret_cast<const JSJitInfo*>(&releaseEvents_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getSelection", genericMethod, reinterpret_cast<const JSJitInfo*>(&getSelection_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getComputedStyle", genericMethod, reinterpret_cast<const JSJitInfo*>(&getComputedStyle_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("matchMedia", genericMethod, reinterpret_cast<const JSJitInfo*>(&matchMedia_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("moveTo", genericMethod, reinterpret_cast<const JSJitInfo*>(&moveTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("moveBy", genericMethod, reinterpret_cast<const JSJitInfo*>(&moveBy_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("resizeTo", genericMethod, reinterpret_cast<const JSJitInfo*>(&resizeTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("resizeBy", genericMethod, reinterpret_cast<const JSJitInfo*>(&resizeBy_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scroll", genericMethod, reinterpret_cast<const JSJitInfo*>(&scroll_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scrollTo", genericMethod, reinterpret_cast<const JSJitInfo*>(&scrollTo_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scrollBy", genericMethod, reinterpret_cast<const JSJitInfo*>(&scrollBy_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("requestAnimationFrame", genericMethod, reinterpret_cast<const JSJitInfo*>(&requestAnimationFrame_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("cancelAnimationFrame", genericMethod, reinterpret_cast<const JSJitInfo*>(&cancelAnimationFrame_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getDefaultComputedStyle", genericMethod, reinterpret_cast<const JSJitInfo*>(&getDefaultComputedStyle_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scrollByLines", genericMethod, reinterpret_cast<const JSJitInfo*>(&scrollByLines_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scrollByPages", genericMethod, reinterpret_cast<const JSJitInfo*>(&scrollByPages_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("sizeToContent", genericMethod, reinterpret_cast<const JSJitInfo*>(&sizeToContent_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("updateCommands", genericMethod, reinterpret_cast<const JSJitInfo*>(&updateCommands_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("find", genericMethod, reinterpret_cast<const JSJitInfo*>(&find_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dump", genericMethod, reinterpret_cast<const JSJitInfo*>(&dump_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setResizable", genericMethod, reinterpret_cast<const JSJitInfo*>(&setResizable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("getAttention", genericMethod, reinterpret_cast<const JSJitInfo*>(&getAttention_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getAttentionWithCycleCount", genericMethod, reinterpret_cast<const JSJitInfo*>(&getAttentionWithCycleCount_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setCursor", genericMethod, reinterpret_cast<const JSJitInfo*>(&setCursor_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("maximize", genericMethod, reinterpret_cast<const JSJitInfo*>(&maximize_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("minimize", genericMethod, reinterpret_cast<const JSJitInfo*>(&minimize_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("restore", genericMethod, reinterpret_cast<const JSJitInfo*>(&restore_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("notifyDefaultButtonLoaded", genericMethod, reinterpret_cast<const JSJitInfo*>(&notifyDefaultButtonLoaded_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getGroupMessageManager", genericMethod, reinterpret_cast<const JSJitInfo*>(&getGroupMessageManager_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("beginWindowMove", genericMethod, reinterpret_cast<const JSJitInfo*>(&beginWindowMove_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("fetch", genericPromiseReturningMethod, reinterpret_cast<const JSJitInfo*>(&fetch_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createImageBitmap", genericPromiseReturningMethod, reinterpret_cast<const JSJitInfo*>(&createImageBitmap_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("QueryInterface", QueryInterface, nullptr, 1, 0, nullptr),
  JS_FS_END,
  JS_FNSPEC("btoa", genericMethod, reinterpret_cast<const JSJitInfo*>(&btoa_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("atob", genericMethod, reinterpret_cast<const JSJitInfo*>(&atob_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  //MODI_FY
  JS_FNSPEC("test", genericMethod, reinterpret_cast<const JSJitInfo*>(&test_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  //MODI_FY
  JS_FNSPEC("setTimeout", genericMethod, reinterpret_cast<const JSJitInfo*>(&setTimeout_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clearTimeout", genericMethod, reinterpret_cast<const JSJitInfo*>(&clearTimeout_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setInterval", genericMethod, reinterpret_cast<const JSJitInfo*>(&setInterval_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clearInterval", genericMethod, reinterpret_cast<const JSJitInfo*>(&clearInterval_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static PrefableDisablers sMethods_disablers10 = {
  true, false, 0, &nsGlobalWindow::IsShowModalDialogEnabled
};

static PrefableDisablers sMethods_disablers36 = {
  true, false, 0, &nsGlobalWindow::IsPrivilegedChromeWindow
};

static PrefableDisablers sMethods_disablers49 = {
  true, false, 0, &WantsQueryInterface<nsGlobalWindow>::Enabled
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { &sMethods_disablers10, &sMethods_specs[10] },
  { nullptr, &sMethods_specs[12] },
  { &sMethods_disablers36, &sMethods_specs[36] },
  { nullptr, &sMethods_specs[46] },
  { &sMethods_disablers49, &sMethods_specs[49] },
  { nullptr, &sMethods_specs[51] },
  { nullptr, nullptr }
};

static jsid sMethods_ids[58];

static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("mozScrollSnap", genericMethod, reinterpret_cast<const JSJitInfo*>(&mozScrollSnap_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("mozRequestOverfill", genericMethod, reinterpret_cast<const JSJitInfo*>(&mozRequestOverfill_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("back", genericMethod, reinterpret_cast<const JSJitInfo*>(&back_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("forward", genericMethod, reinterpret_cast<const JSJitInfo*>(&forward_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("home", genericMethod, reinterpret_cast<const JSJitInfo*>(&home_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("openDialog", genericMethod, reinterpret_cast<const JSJitInfo*>(&openDialog_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getInterface", genericMethod, reinterpret_cast<const JSJitInfo*>(&getInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { nullptr, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeMethods_ids[8];

static const JSPropertySpec sAttributes_specs[] = {
  { "self", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &self_getterinfo } }, { { genericSetter, &self_setterinfo } } } } },
  { "name", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &name_getterinfo } }, { { genericSetter, &name_setterinfo } } } } },
  { "history", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &history_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "customElements", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &customElements_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "locationbar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &locationbar_getterinfo } }, { { genericSetter, &locationbar_setterinfo } } } } },
  { "menubar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &menubar_getterinfo } }, { { genericSetter, &menubar_setterinfo } } } } },
  { "personalbar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &personalbar_getterinfo } }, { { genericSetter, &personalbar_setterinfo } } } } },
  { "scrollbars", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollbars_getterinfo } }, { { genericSetter, &scrollbars_setterinfo } } } } },
  { "statusbar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &statusbar_getterinfo } }, { { genericSetter, &statusbar_setterinfo } } } } },
  { "toolbar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &toolbar_getterinfo } }, { { genericSetter, &toolbar_setterinfo } } } } },
  { "status", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &status_getterinfo } }, { { genericSetter, &status_setterinfo } } } } },
  { "closed", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &closed_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "frames", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &frames_getterinfo } }, { { genericSetter, &frames_setterinfo } } } } },
  { "length", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &length_getterinfo } }, { { genericSetter, &length_setterinfo } } } } },
  { "opener", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &opener_getterinfo } }, { { genericSetter, &opener_setterinfo } } } } },
  { "parent", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericCrossOriginGetter, &parent_getterinfo } }, { { genericSetter, &parent_setterinfo } } } } },
  { "frameElement", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &frameElement_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "navigator", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &navigator_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "external", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &external_getterinfo } }, { { genericSetter, &external_setterinfo } } } } },
  JS_PS_END,
  { "applicationCache", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &applicationCache_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "oninstall", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oninstall_getterinfo } }, { { genericSetter, &oninstall_setterinfo } } } } },
  JS_PS_END,
  { "screen", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &screen_getterinfo } }, { { genericSetter, &screen_setterinfo } } } } },
  { "innerWidth", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &innerWidth_getterinfo } }, { { genericSetter, &innerWidth_setterinfo } } } } },
  { "innerHeight", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &innerHeight_getterinfo } }, { { genericSetter, &innerHeight_setterinfo } } } } },
  { "scrollX", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollX_getterinfo } }, { { genericSetter, &scrollX_setterinfo } } } } },
  { "pageXOffset", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &pageXOffset_getterinfo } }, { { genericSetter, &pageXOffset_setterinfo } } } } },
  { "scrollY", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollY_getterinfo } }, { { genericSetter, &scrollY_setterinfo } } } } },
  { "pageYOffset", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &pageYOffset_getterinfo } }, { { genericSetter, &pageYOffset_setterinfo } } } } },
  { "screenX", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &screenX_getterinfo } }, { { genericSetter, &screenX_setterinfo } } } } },
  { "screenY", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &screenY_getterinfo } }, { { genericSetter, &screenY_setterinfo } } } } },
  { "outerWidth", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &outerWidth_getterinfo } }, { { genericSetter, &outerWidth_setterinfo } } } } },
  { "outerHeight", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &outerHeight_getterinfo } }, { { genericSetter, &outerHeight_setterinfo } } } } },
  { "performance", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &performance_getterinfo } }, { { genericSetter, &performance_setterinfo } } } } },
  JS_PS_END,
  { "caches", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &caches_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "mozInnerScreenX", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &mozInnerScreenX_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "mozInnerScreenY", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &mozInnerScreenY_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "devicePixelRatio", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &devicePixelRatio_getterinfo } }, { { genericSetter, &devicePixelRatio_setterinfo } } } } },
  { "scrollMaxX", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollMaxX_getterinfo } }, { { genericSetter, &scrollMaxX_setterinfo } } } } },
  { "scrollMaxY", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollMaxY_getterinfo } }, { { genericSetter, &scrollMaxY_setterinfo } } } } },
  { "fullScreen", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &fullScreen_getterinfo } }, { { genericSetter, &fullScreen_setterinfo } } } } },
  { "mozPaintCount", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &mozPaintCount_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "onwheel", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwheel_getterinfo } }, { { genericSetter, &onwheel_setterinfo } } } } },
  { "ondevicemotion", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondevicemotion_getterinfo } }, { { genericSetter, &ondevicemotion_setterinfo } } } } },
  { "ondeviceorientation", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondeviceorientation_getterinfo } }, { { genericSetter, &ondeviceorientation_setterinfo } } } } },
  { "onabsolutedeviceorientation", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onabsolutedeviceorientation_getterinfo } }, { { genericSetter, &onabsolutedeviceorientation_setterinfo } } } } },
  { "ondeviceproximity", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondeviceproximity_getterinfo } }, { { genericSetter, &ondeviceproximity_setterinfo } } } } },
  { "onuserproximity", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onuserproximity_getterinfo } }, { { genericSetter, &onuserproximity_setterinfo } } } } },
  { "ondevicelight", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondevicelight_getterinfo } }, { { genericSetter, &ondevicelight_setterinfo } } } } },
  { "content", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &content_getterinfo } }, { { genericSetter, &content_setterinfo } } } } },
  { "isSecureContext", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &isSecureContext_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "sidebar", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &sidebar_getterinfo } }, { { genericSetter, &sidebar_setterinfo } } } } },
  JS_PS_END,
  { "onvrdisplayconnect", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onvrdisplayconnect_getterinfo } }, { { genericSetter, &onvrdisplayconnect_setterinfo } } } } },
  { "onvrdisplaydisconnect", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onvrdisplaydisconnect_getterinfo } }, { { genericSetter, &onvrdisplaydisconnect_setterinfo } } } } },
  { "onvrdisplaypresentchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onvrdisplaypresentchange_getterinfo } }, { { genericSetter, &onvrdisplaypresentchange_setterinfo } } } } },
  JS_PS_END,
  { "windowState", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &windowState_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "browserDOMWindow", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &browserDOMWindow_getterinfo } }, { { genericSetter, &browserDOMWindow_setterinfo } } } } },
  { "messageManager", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &messageManager_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "crypto", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &crypto_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "onabort", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onabort_getterinfo } }, { { genericSetter, &onabort_setterinfo } } } } },
  { "onblur", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onblur_getterinfo } }, { { genericSetter, &onblur_setterinfo } } } } },
  { "onfocus", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onfocus_getterinfo } }, { { genericSetter, &onfocus_setterinfo } } } } },
  { "oncanplay", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oncanplay_getterinfo } }, { { genericSetter, &oncanplay_setterinfo } } } } },
  { "oncanplaythrough", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oncanplaythrough_getterinfo } }, { { genericSetter, &oncanplaythrough_setterinfo } } } } },
  { "onchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onchange_getterinfo } }, { { genericSetter, &onchange_setterinfo } } } } },
  { "onclick", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onclick_getterinfo } }, { { genericSetter, &onclick_setterinfo } } } } },
  { "oncontextmenu", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oncontextmenu_getterinfo } }, { { genericSetter, &oncontextmenu_setterinfo } } } } },
  { "ondblclick", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondblclick_getterinfo } }, { { genericSetter, &ondblclick_setterinfo } } } } },
  { "ondrag", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondrag_getterinfo } }, { { genericSetter, &ondrag_setterinfo } } } } },
  { "ondragend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragend_getterinfo } }, { { genericSetter, &ondragend_setterinfo } } } } },
  { "ondragenter", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragenter_getterinfo } }, { { genericSetter, &ondragenter_setterinfo } } } } },
  { "ondragexit", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragexit_getterinfo } }, { { genericSetter, &ondragexit_setterinfo } } } } },
  { "ondragleave", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragleave_getterinfo } }, { { genericSetter, &ondragleave_setterinfo } } } } },
  { "ondragover", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragover_getterinfo } }, { { genericSetter, &ondragover_setterinfo } } } } },
  { "ondragstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondragstart_getterinfo } }, { { genericSetter, &ondragstart_setterinfo } } } } },
  { "ondrop", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondrop_getterinfo } }, { { genericSetter, &ondrop_setterinfo } } } } },
  { "ondurationchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ondurationchange_getterinfo } }, { { genericSetter, &ondurationchange_setterinfo } } } } },
  { "onemptied", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onemptied_getterinfo } }, { { genericSetter, &onemptied_setterinfo } } } } },
  { "onended", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onended_getterinfo } }, { { genericSetter, &onended_setterinfo } } } } },
  { "oninput", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oninput_getterinfo } }, { { genericSetter, &oninput_setterinfo } } } } },
  { "oninvalid", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &oninvalid_getterinfo } }, { { genericSetter, &oninvalid_setterinfo } } } } },
  { "onkeydown", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onkeydown_getterinfo } }, { { genericSetter, &onkeydown_setterinfo } } } } },
  { "onkeypress", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onkeypress_getterinfo } }, { { genericSetter, &onkeypress_setterinfo } } } } },
  { "onkeyup", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onkeyup_getterinfo } }, { { genericSetter, &onkeyup_setterinfo } } } } },
  { "onload", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onload_getterinfo } }, { { genericSetter, &onload_setterinfo } } } } },
  { "onloadeddata", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onloadeddata_getterinfo } }, { { genericSetter, &onloadeddata_setterinfo } } } } },
  { "onloadedmetadata", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onloadedmetadata_getterinfo } }, { { genericSetter, &onloadedmetadata_setterinfo } } } } },
  { "onloadend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onloadend_getterinfo } }, { { genericSetter, &onloadend_setterinfo } } } } },
  { "onloadstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onloadstart_getterinfo } }, { { genericSetter, &onloadstart_setterinfo } } } } },
  { "onmousedown", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmousedown_getterinfo } }, { { genericSetter, &onmousedown_setterinfo } } } } },
  { "onmouseenter", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericLenientGetter, &onmouseenter_getterinfo } }, { { genericLenientSetter, &onmouseenter_setterinfo } } } } },
  { "onmouseleave", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericLenientGetter, &onmouseleave_getterinfo } }, { { genericLenientSetter, &onmouseleave_setterinfo } } } } },
  { "onmousemove", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmousemove_getterinfo } }, { { genericSetter, &onmousemove_setterinfo } } } } },
  { "onmouseout", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmouseout_getterinfo } }, { { genericSetter, &onmouseout_setterinfo } } } } },
  { "onmouseover", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmouseover_getterinfo } }, { { genericSetter, &onmouseover_setterinfo } } } } },
  { "onmouseup", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmouseup_getterinfo } }, { { genericSetter, &onmouseup_setterinfo } } } } },
  { "onpause", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpause_getterinfo } }, { { genericSetter, &onpause_setterinfo } } } } },
  { "onplay", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onplay_getterinfo } }, { { genericSetter, &onplay_setterinfo } } } } },
  { "onplaying", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onplaying_getterinfo } }, { { genericSetter, &onplaying_setterinfo } } } } },
  { "onprogress", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onprogress_getterinfo } }, { { genericSetter, &onprogress_setterinfo } } } } },
  { "onratechange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onratechange_getterinfo } }, { { genericSetter, &onratechange_setterinfo } } } } },
  { "onreset", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onreset_getterinfo } }, { { genericSetter, &onreset_setterinfo } } } } },
  { "onresize", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onresize_getterinfo } }, { { genericSetter, &onresize_setterinfo } } } } },
  { "onscroll", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onscroll_getterinfo } }, { { genericSetter, &onscroll_setterinfo } } } } },
  { "onseeked", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onseeked_getterinfo } }, { { genericSetter, &onseeked_setterinfo } } } } },
  { "onseeking", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onseeking_getterinfo } }, { { genericSetter, &onseeking_setterinfo } } } } },
  { "onselect", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onselect_getterinfo } }, { { genericSetter, &onselect_setterinfo } } } } },
  { "onshow", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onshow_getterinfo } }, { { genericSetter, &onshow_setterinfo } } } } },
  { "onstalled", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onstalled_getterinfo } }, { { genericSetter, &onstalled_setterinfo } } } } },
  { "onsubmit", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onsubmit_getterinfo } }, { { genericSetter, &onsubmit_setterinfo } } } } },
  { "onsuspend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onsuspend_getterinfo } }, { { genericSetter, &onsuspend_setterinfo } } } } },
  { "ontimeupdate", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontimeupdate_getterinfo } }, { { genericSetter, &ontimeupdate_setterinfo } } } } },
  { "onvolumechange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onvolumechange_getterinfo } }, { { genericSetter, &onvolumechange_setterinfo } } } } },
  { "onwaiting", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwaiting_getterinfo } }, { { genericSetter, &onwaiting_setterinfo } } } } },
  JS_PS_END,
  { "onselectstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onselectstart_getterinfo } }, { { genericSetter, &onselectstart_setterinfo } } } } },
  JS_PS_END,
  { "ontoggle", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontoggle_getterinfo } }, { { genericSetter, &ontoggle_setterinfo } } } } },
  JS_PS_END,
  { "onpointercancel", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointercancel_getterinfo } }, { { genericSetter, &onpointercancel_setterinfo } } } } },
  { "onpointerdown", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerdown_getterinfo } }, { { genericSetter, &onpointerdown_setterinfo } } } } },
  { "onpointerup", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerup_getterinfo } }, { { genericSetter, &onpointerup_setterinfo } } } } },
  { "onpointermove", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointermove_getterinfo } }, { { genericSetter, &onpointermove_setterinfo } } } } },
  { "onpointerout", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerout_getterinfo } }, { { genericSetter, &onpointerout_setterinfo } } } } },
  { "onpointerover", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerover_getterinfo } }, { { genericSetter, &onpointerover_setterinfo } } } } },
  { "onpointerenter", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerenter_getterinfo } }, { { genericSetter, &onpointerenter_setterinfo } } } } },
  { "onpointerleave", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpointerleave_getterinfo } }, { { genericSetter, &onpointerleave_setterinfo } } } } },
  { "ongotpointercapture", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ongotpointercapture_getterinfo } }, { { genericSetter, &ongotpointercapture_setterinfo } } } } },
  { "onlostpointercapture", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onlostpointercapture_getterinfo } }, { { genericSetter, &onlostpointercapture_setterinfo } } } } },
  JS_PS_END,
  { "onmozfullscreenchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmozfullscreenchange_getterinfo } }, { { genericSetter, &onmozfullscreenchange_setterinfo } } } } },
  { "onmozfullscreenerror", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmozfullscreenerror_getterinfo } }, { { genericSetter, &onmozfullscreenerror_setterinfo } } } } },
  JS_PS_END,
  { "onmozpointerlockchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmozpointerlockchange_getterinfo } }, { { genericSetter, &onmozpointerlockchange_setterinfo } } } } },
  { "onmozpointerlockerror", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmozpointerlockerror_getterinfo } }, { { genericSetter, &onmozpointerlockerror_setterinfo } } } } },
  JS_PS_END,
  { "onanimationend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onanimationend_getterinfo } }, { { genericSetter, &onanimationend_setterinfo } } } } },
  { "onanimationiteration", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onanimationiteration_getterinfo } }, { { genericSetter, &onanimationiteration_setterinfo } } } } },
  { "onanimationstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onanimationstart_getterinfo } }, { { genericSetter, &onanimationstart_setterinfo } } } } },
  { "ontransitionend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontransitionend_getterinfo } }, { { genericSetter, &ontransitionend_setterinfo } } } } },
  { "onwebkitanimationend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwebkitanimationend_getterinfo } }, { { genericSetter, &onwebkitanimationend_setterinfo } } } } },
  { "onwebkitanimationiteration", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwebkitanimationiteration_getterinfo } }, { { genericSetter, &onwebkitanimationiteration_setterinfo } } } } },
  { "onwebkitanimationstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwebkitanimationstart_getterinfo } }, { { genericSetter, &onwebkitanimationstart_setterinfo } } } } },
  { "onwebkittransitionend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onwebkittransitionend_getterinfo } }, { { genericSetter, &onwebkittransitionend_setterinfo } } } } },
  JS_PS_END,
  { "u2f", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &u2f_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "indexedDB", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &indexedDB_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "onerror", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onerror_getterinfo } }, { { genericSetter, &onerror_setterinfo } } } } },
  JS_PS_END,
  { "speechSynthesis", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &speechSynthesis_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "ontouchstart", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontouchstart_getterinfo } }, { { genericSetter, &ontouchstart_setterinfo } } } } },
  { "ontouchend", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontouchend_getterinfo } }, { { genericSetter, &ontouchend_setterinfo } } } } },
  { "ontouchmove", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontouchmove_getterinfo } }, { { genericSetter, &ontouchmove_setterinfo } } } } },
  { "ontouchcancel", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ontouchcancel_getterinfo } }, { { genericSetter, &ontouchcancel_setterinfo } } } } },
  JS_PS_END,
  { "onafterprint", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onafterprint_getterinfo } }, { { genericSetter, &onafterprint_setterinfo } } } } },
  { "onbeforeprint", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onbeforeprint_getterinfo } }, { { genericSetter, &onbeforeprint_setterinfo } } } } },
  { "onbeforeunload", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onbeforeunload_getterinfo } }, { { genericSetter, &onbeforeunload_setterinfo } } } } },
  { "onhashchange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onhashchange_getterinfo } }, { { genericSetter, &onhashchange_setterinfo } } } } },
  { "onlanguagechange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onlanguagechange_getterinfo } }, { { genericSetter, &onlanguagechange_setterinfo } } } } },
  { "onmessage", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onmessage_getterinfo } }, { { genericSetter, &onmessage_setterinfo } } } } },
  { "onoffline", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onoffline_getterinfo } }, { { genericSetter, &onoffline_setterinfo } } } } },
  { "ononline", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &ononline_getterinfo } }, { { genericSetter, &ononline_setterinfo } } } } },
  { "onpagehide", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpagehide_getterinfo } }, { { genericSetter, &onpagehide_setterinfo } } } } },
  { "onpageshow", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpageshow_getterinfo } }, { { genericSetter, &onpageshow_setterinfo } } } } },
  { "onpopstate", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onpopstate_getterinfo } }, { { genericSetter, &onpopstate_setterinfo } } } } },
  { "onstorage", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onstorage_getterinfo } }, { { genericSetter, &onstorage_setterinfo } } } } },
  { "onunload", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &onunload_getterinfo } }, { { genericSetter, &onunload_setterinfo } } } } },
  { "localStorage", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &localStorage_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "dialogArguments", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &dialogArguments_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "returnValue", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &returnValue_getterinfo } }, { { genericSetter, &returnValue_setterinfo } } } } },
  JS_PS_END,
  { "sessionStorage", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &sessionStorage_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END
};

static PrefableDisablers sAttributes_disablers4 = {
  true, false, 0, &CustomElementsRegistry::IsCustomElementsEnabled
};

static PrefableDisablers sAttributes_disablers22 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers24 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers39 = {
  true, false, 0, &mozilla::dom::cache::CacheStorage::PrefEnabled
};

static PrefableDisablers sAttributes_disablers59 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers63 = {
  true, false, 0, &nsGlobalWindow::IsPrivilegedChromeWindow
};

static PrefableDisablers sAttributes_disablers124 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers126 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers128 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers142 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers154 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers159 = {
  true, false, 0, nullptr
};

static PrefableDisablers sAttributes_disablers161 = {
  true, false, 0, &nsGenericHTMLElement::TouchEventsEnabled
};

static PrefableDisablers sAttributes_disablers181 = {
  true, false, 0, &nsGlobalWindow::IsModalContentWindow
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers4, &sAttributes_specs[4] },
  { nullptr, &sAttributes_specs[6] },
  { &sAttributes_disablers22, &sAttributes_specs[22] },
  { &sAttributes_disablers24, &sAttributes_specs[24] },
  { nullptr, &sAttributes_specs[26] },
  { &sAttributes_disablers39, &sAttributes_specs[39] },
  { nullptr, &sAttributes_specs[41] },
  { &sAttributes_disablers59, &sAttributes_specs[59] },
  { &sAttributes_disablers63, &sAttributes_specs[63] },
  { nullptr, &sAttributes_specs[67] },
  { &sAttributes_disablers124, &sAttributes_specs[124] },
  { &sAttributes_disablers126, &sAttributes_specs[126] },
  { &sAttributes_disablers128, &sAttributes_specs[128] },
  { nullptr, &sAttributes_specs[139] },
  { &sAttributes_disablers142, &sAttributes_specs[142] },
  { nullptr, &sAttributes_specs[145] },
  { &sAttributes_disablers154, &sAttributes_specs[154] },
  { nullptr, &sAttributes_specs[156] },
  { &sAttributes_disablers159, &sAttributes_specs[159] },
  { &sAttributes_disablers161, &sAttributes_specs[161] },
  { nullptr, &sAttributes_specs[166] },
  { &sAttributes_disablers181, &sAttributes_specs[181] },
  { nullptr, &sAttributes_specs[184] },
  { nullptr, nullptr }
};

static jsid sAttributes_ids[186];

static const JSPropertySpec sChromeAttributes_specs[] = {
  { "controllers", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &controllers_getterinfo } }, { { genericSetter, &controllers_setterinfo } } } } },
  { "realFrameElement", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &realFrameElement_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "scrollMinX", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollMinX_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "scrollMinY", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &scrollMinY_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "MozSelfSupport", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &MozSelfSupport_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "_content", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &_content_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "windowRoot", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { genericGetter, &windowRoot_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeAttributes_ids[8];

static const JSPropertySpec sUnforgeableAttributes_specs[] = {
  { "window", JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_PERMANENT, { { { { genericCrossOriginGetter, &window_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "document", JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_PERMANENT, { { { { genericGetter, &document_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "location", JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_PERMANENT, { { { { genericCrossOriginGetter, &location_getterinfo } }, { { genericCrossOriginSetter, &location_setterinfo } } } } },
  { "top", JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_PERMANENT, { { { { genericCrossOriginGetter, &top_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sUnforgeableAttributes[] = {
  { nullptr, &sUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static jsid sUnforgeableAttributes_ids[5];

static const ConstantSpec sConstants_specs[] = {
  { "STATE_MAXIMIZED", JS::Int32Value(1) },
  { "STATE_MINIMIZED", JS::Int32Value(2) },
  { "STATE_NORMAL", JS::Int32Value(3) },
  { "STATE_FULLSCREEN", JS::Int32Value(4) },
  { 0, JS::UndefinedValue() }
};

static PrefableDisablers sConstants_disablers0 = {
  true, false, 0, &nsGlobalWindow::IsPrivilegedChromeWindow
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const ConstantSpec> sConstants[] = {
  { &sConstants_disablers0, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static jsid sConstants_ids[5];


static const NativePropertiesN<4> sNativeProperties = {
  -1,
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  true,  2 /* sUnforgeableAttributes */,
  true,  3 /* sConstants */,
  {
    { sMethods, sMethods_ids, sMethods_specs },
    { sAttributes, sAttributes_ids, sAttributes_specs },
    { sUnforgeableAttributes, sUnforgeableAttributes_ids, sUnforgeableAttributes_specs },
    { sConstants, sConstants_ids, sConstants_specs }
  }
};

static const NativePropertiesN<2> sChromeOnlyNativeProperties = {
  -1,
  false, 0,
  false, 0,
  true,  0 /* sChromeMethods */,
  true,  1 /* sChromeAttributes */,
  false, 0,
  false, 0,
  false, 0,
  {
    { sChromeMethods, sChromeMethods_ids, sChromeMethods_specs },
    { sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs }
  }
};

static bool
ResolveOwnPropertyViaResolve(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "Value", "Window");
    }
  }
  {
    // Since we're dealing with an Xray, do the resolve on the
    // underlying object first.  That gives it a chance to
    // define properties on the actual object as needed, and
    // then use the fact that it created the objects as a flag
    // to avoid re-resolving the properties if someone deletes
    // them.
    JSAutoCompartment ac(cx, obj);
    JS::Rooted<JS::PropertyDescriptor> objDesc(cx);
    if (!self->DoResolve(cx, obj, id, &objDesc)) {
      return false;
    }
    // If desc.value() is undefined, then the DoResolve call
    // has already defined the property on the object.  Don't
    // try to also define it.
    if (objDesc.object() &&
        !objDesc.value().isUndefined() &&
        !JS_DefinePropertyById(cx, obj, id, objDesc)) {
      return false;
    }
  }
  return self->DoResolve(cx, wrapper, id, desc);
}

static bool
EnumerateOwnPropertiesViaGetOwnPropertyNames(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::AutoIdVector& props)
{
  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "Value", "Window");
    }
  }
  AutoTArray<nsString, 8> names;
  binding_detail::FastErrorResult rv;
  self->GetOwnPropertyNames(cx, names, rv);
  if (rv.MaybeSetPendingException(cx)) {
    return false;
  }
  // OK to pass null as "proxy" because it's ignored if
  // shadowPrototypeProperties is true
  return AppendNamedPropertyIds(cx, nullptr, names, true, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnPropertyViaResolve,
  EnumerateOwnPropertiesViaGetOwnPropertyNames,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::Window,
  constructors::id::Window,
  EventTargetBinding::sNativePropertyHooks
} };

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::Window,
  PrototypeTraits<prototypes::id::Window>::Depth,
  sNativePropertyHooks,
  "function Window() {\n    [native code]\n}",
  EventTargetBinding::GetConstructorObject
};

static bool
_resolve(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, bool* resolvedp)
{
  if (!ResolveGlobal(cx, obj, id, resolvedp)) {
    return false;
  }
  if (*resolvedp) {
    return true;
  }

  nsGlobalWindow* self = UnwrapPossiblyNotInitializedDOMObject<nsGlobalWindow>(obj);
  JS::Rooted<JS::PropertyDescriptor> desc(cx);
  if (!self->DoResolve(cx, obj, id, &desc)) {
    return false;
  }
  if (!desc.object()) {
    return true;
  }
  // If desc.value() is undefined, then the DoResolve call
  // has already defined it on the object.  Don't try to also
  // define it.
  if (!desc.value().isUndefined()) {
    desc.attributesRef() |= JSPROP_RESOLVING;
    if (!JS_DefinePropertyById(cx, obj, id, desc)) {
      return false;
    }
  }
  *resolvedp = true;
  return true;
}

static bool
_mayResolve(const JSAtomState& names, jsid id, JSObject* maybeObj)
{
  if (MayResolveGlobal(names, id, maybeObj)) {
    return true;
  }

  return nsGlobalWindow::MayResolve(id);
}

static bool
_enumerate(JSContext* cx, JS::Handle<JSObject*> obj)
{
  if (!EnumerateGlobal(cx, obj)) {
    return false;
  }

  nsGlobalWindow* self;
  {
    nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindow>(obj, self);
    if (NS_FAILED(rv)) {
      return ThrowErrorMessage(cx, MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "Value", "Window");
    }
  }
  AutoTArray<nsString, 8> names;
  binding_detail::FastErrorResult rv;
  self->GetOwnPropertyNames(cx, names, rv);
  if (rv.MaybeSetPendingException(cx)) {
    return false;
  }
  bool dummy;
  for (uint32_t i = 0; i < names.Length(); ++i) {
    if (!JS_HasUCProperty(cx, obj, names[i].get(), names[i].Length(), &dummy)) {
      return false;
    }
  }
  return true;
}

static JSObject*
GetNamedPropertiesObject(JSContext* aCx)
{
  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the named properties object has already been created */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);

  JS::Heap<JSObject*>& namedPropertiesObject = protoAndIfaceCache.EntrySlotOrCreate(namedpropertiesobjects::id::Window);
  if (!namedPropertiesObject) {
    JS::Rooted<JSObject*> parentProto(aCx, EventTargetBinding::GetProtoObjectHandle(aCx));
    if (!parentProto) {
      return nullptr;
    }
    namedPropertiesObject = nsGlobalWindow::CreateNamedPropertiesObject(aCx, parentProto);
    DebugOnly<const DOMIfaceAndProtoJSClass*> clasp =
      DOMIfaceAndProtoJSClass::FromJSClass(js::GetObjectClass(namedPropertiesObject));
    MOZ_ASSERT(clasp->mType == eNamedPropertiesObject,
               "Expected nsGlobalWindow::CreateNamedPropertiesObject to return a named properties object");
    MOZ_ASSERT(clasp->mNativeHooks,
               "The named properties object for nsGlobalWindow should have NativePropertyHooks.");
    MOZ_ASSERT(clasp->mNativeHooks->mResolveOwnProperty,
               "Don't know how to resolve the properties of the named properties object for nsGlobalWindow.");
    MOZ_ASSERT(clasp->mNativeHooks->mEnumerateOwnProperties,
               "Don't know how to enumerate the properties of the named properties object for nsGlobalWindow.");
  }
  return namedPropertiesObject.get();
}

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "WindowPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eGlobalInterfacePrototype,
  false,
  prototypes::id::Window,
  PrototypeTraits<prototypes::id::Window>::Depth,
  sNativePropertyHooks,
  "[object WindowPrototype]",
  GetNamedPropertiesObject
};

JSObject*
DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal)
{
  return GetConstructorObjectHandle(aCx, aDefineOnGlobal);
}

static const js::ClassOps sClassOps = {
  nullptr, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* getProperty */
  nullptr,               /* setProperty */
  _enumerate, /* enumerate */
  _resolve, /* resolve */
  _mayResolve, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  JS_GlobalObjectTraceHook, /* trace */
};

static const js::ClassExtension sClassExtension = {
  nullptr, /* weakmapKeyDelegateOp */
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "Window",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_DOM_GLOBAL | JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(DOM_GLOBAL_SLOTS),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::EventTarget, prototypes::id::Window, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  IsBaseOf<nsISupports, nsGlobalWindow >::value,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<nsGlobalWindow>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<nsGlobalWindow>::Get()
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(JSCLASS_GLOBAL_APPLICATION_SLOTS >= 5,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

static bool
UpdateMemberSlots(JSContext* aCx, JS::Handle<JSObject*> aWrapper, nsGlobalWindow* aObject)
{
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);

  if (!get_document(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  if (!get_performance(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  return true;
}

bool
Wrap(JSContext* aCx, nsGlobalWindow* aObject, nsWrapperCache* aCache, JS::CompartmentOptions& aOptions, JSPrincipals* aPrincipal, bool aInitStandardClasses, JS::MutableHandle<JSObject*> aReflector)
{
  MOZ_ASSERT(static_cast<nsGlobalWindow*>(aObject) ==
             reinterpret_cast<nsGlobalWindow*>(aObject),
             "Multiple inheritance for nsGlobalWindow is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject),
             "Multiple inheritance for mozilla::dom::EventTarget is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  if (!CreateGlobal<nsGlobalWindow, GetProtoObjectHandle>(aCx,
                                   aObject,
                                   aCache,
                                   sClass.ToJSClass(),
                                   aOptions,
                                   aPrincipal,
                                   aInitStandardClasses,
                                   aReflector)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }

  // aReflector is a new global, so has a new compartment.  Enter it
  // before doing anything with it.
  JSAutoCompartment ac(aCx, aReflector);

  if (!DefineProperties(aCx, aReflector, sNativeProperties.Upcast(), nsContentUtils::ThreadsafeIsCallerChrome() ? sChromeOnlyNativeProperties.Upcast() : nullptr)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }

  if (!DefineUnforgeableAttributes(aCx, aReflector, sUnforgeableAttributes)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }

  if (!UpdateMemberSlots(aCx, aReflector, aObject)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }

  return true;
}

bool
ClearCachedDocumentValue(JSContext* aCx, nsGlobalWindow* aObject)
{
  JS::Rooted<JSObject*> obj(aCx);
  obj = aObject->GetWrapper();
  if (!obj) {
    return true;
  }
  JS::Rooted<JS::Value> oldValue(aCx, js::GetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2)));
  js::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2), JS::UndefinedValue());
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);
  JSAutoCompartment ac(aCx, obj);
  if (!get_document(aCx, obj, aObject, args)) {
    js::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2), oldValue);
    return false;
  }
  return true;
}

bool
ClearCachedPerformanceValue(JSContext* aCx, nsGlobalWindow* aObject)
{
  JS::Rooted<JSObject*> obj(aCx);
  obj = aObject->GetWrapper();
  if (!obj) {
    return true;
  }
  JS::Rooted<JS::Value> oldValue(aCx, js::GetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 3)));
  js::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 3), JS::UndefinedValue());
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);
  JSAutoCompartment ac(aCx, obj);
  if (!get_performance(aCx, obj, aObject, args)) {
    js::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 3), oldValue);
    return false;
  }
  return true;
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, GetNamedPropertiesObject(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(EventTargetBinding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static bool sIdsInited = false;
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sMethods, sMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sChromeAttributes, sChromeAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sAttributes, sAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sUnforgeableAttributes, sUnforgeableAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sConstants, sConstants_ids)) {
      return;
    }
    sIdsInited = true;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited && NS_IsMainThread()) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sAttributes[3].disablers->enabled, "browser.cache.offline.enable");
    Preferences::AddBoolVarCache(&sAttributes[4].disablers->enabled, "dom.manifest.oninstall");
    Preferences::AddBoolVarCache(&sAttributes[8].disablers->enabled, "dom.vr.enabled");
    Preferences::AddBoolVarCache(&sAttributes[11].disablers->enabled, "dom.select_events.enabled");
    Preferences::AddBoolVarCache(&sAttributes[12].disablers->enabled, "dom.details_element.enabled");
    Preferences::AddBoolVarCache(&sAttributes[13].disablers->enabled, "dom.w3c_pointer_events.enabled");
    Preferences::AddBoolVarCache(&sAttributes[15].disablers->enabled, "pointer-lock-api.prefixed.enabled");
    Preferences::AddBoolVarCache(&sAttributes[17].disablers->enabled, "security.webauth.u2f");
    Preferences::AddBoolVarCache(&sAttributes[19].disablers->enabled, "media.webspeech.synth.enabled");
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::Window);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::Window);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nsContentUtils::ThreadsafeIsCallerChrome() ? sChromeOnlyNativeProperties.Upcast() : nullptr,
                              "Window", aDefineOnGlobal,
                              nullptr,
                              true);

  if (*&aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::Window)) {
    bool succeeded;
    JS::Handle<JSObject*> prot = GetProtoObjectHandle(aCx);
    if (!JS_SetImmutablePrototype(aCx, prot, &succeeded)) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }

    MOZ_ASSERT(succeeded,
               "making a fresh prototype object's [[Prototype]] "
               "immutable can internally fail, but it should "
               "never be unsuccessful");
  }
}

JS::Handle<JSObject*>
GetProtoObjectHandle(JSContext* aCx)
{
  /* Get the interface prototype object for this class.  This will create the
     object as needed. */
  bool aDefineOnGlobal = true;

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);
  if (!protoAndIfaceCache.EntrySlotIfExists(prototypes::id::Window)) {
    JS::Rooted<JSObject*> rootedGlobal(aCx, global);
    CreateInterfaceObjects(aCx, rootedGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceCache.EntrySlotMustExist(prototypes::id::Window).address());
}

JS::Handle<JSObject*>
GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal)
{
  /* Get the interface object for this class.  This will create the object as
     needed. */

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);
  if (!protoAndIfaceCache.EntrySlotIfExists(constructors::id::Window)) {
    JS::Rooted<JSObject*> rootedGlobal(aCx, global);
    CreateInterfaceObjects(aCx, rootedGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceCache.EntrySlotMustExist(constructors::id::Window).address());
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace WindowBinding



} // namespace dom
} // namespace mozilla
